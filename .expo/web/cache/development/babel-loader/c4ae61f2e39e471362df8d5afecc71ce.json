{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _excluded = [\"animationIn\", \"animationInTiming\", \"animationOut\", \"animationOutTiming\", \"avoidKeyboard\", \"coverScreen\", \"hasBackdrop\", \"backdropColor\", \"backdropOpacity\", \"backdropTransitionInTiming\", \"backdropTransitionOutTiming\", \"customBackdrop\", \"children\", \"isVisible\", \"onModalShow\", \"onBackButtonPress\", \"useNativeDriver\", \"propagateSwipe\", \"style\"],\n    _excluded2 = [\"testID\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport * as React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport DeviceEventEmitter from \"react-native-web/dist/exports/DeviceEventEmitter\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport InteractionManager from \"react-native-web/dist/exports/InteractionManager\";\nimport KeyboardAvoidingView from \"react-native-web/dist/exports/KeyboardAvoidingView\";\nimport Modal from \"react-native-web/dist/exports/Modal\";\nimport PanResponder from \"react-native-web/dist/exports/PanResponder\";\nimport BackHandler from \"react-native-web/dist/exports/BackHandler\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport TouchableWithoutFeedback from \"react-native-web/dist/exports/TouchableWithoutFeedback\";\nimport View from \"react-native-web/dist/exports/View\";\nimport * as PropTypes from 'prop-types';\nimport * as animatable from 'react-native-animatable';\nimport { initializeAnimations, buildAnimations, reversePercentage } from \"./utils\";\nimport styles from \"./modal.style\";\ninitializeAnimations();\n\nvar extractAnimationFromProps = function extractAnimationFromProps(props) {\n  return {\n    animationIn: props.animationIn,\n    animationOut: props.animationOut\n  };\n};\n\nexport var ReactNativeModal = function (_React$Component) {\n  _inherits(ReactNativeModal, _React$Component);\n\n  var _super = _createSuper(ReactNativeModal);\n\n  function ReactNativeModal(props) {\n    var _this;\n\n    _classCallCheck(this, ReactNativeModal);\n\n    _this = _super.call(this, props);\n    _this.state = {\n      showContent: true,\n      isVisible: false,\n      deviceWidth: Dimensions.get('window').width,\n      deviceHeight: Dimensions.get('window').height,\n      isSwipeable: !!_this.props.swipeDirection,\n      pan: null\n    };\n    _this.isTransitioning = false;\n    _this.inSwipeClosingState = false;\n    _this.currentSwipingDirection = null;\n    _this.panResponder = null;\n\n    _this.getDeviceHeight = function () {\n      return _this.props.deviceHeight || _this.state.deviceHeight;\n    };\n\n    _this.getDeviceWidth = function () {\n      return _this.props.deviceWidth || _this.state.deviceWidth;\n    };\n\n    _this.onBackButtonPress = function () {\n      if (_this.props.onBackButtonPress && _this.props.isVisible) {\n        _this.props.onBackButtonPress();\n\n        return true;\n      }\n\n      return false;\n    };\n\n    _this.shouldPropagateSwipe = function (evt, gestureState) {\n      return typeof _this.props.propagateSwipe === 'function' ? _this.props.propagateSwipe(evt, gestureState) : _this.props.propagateSwipe;\n    };\n\n    _this.buildPanResponder = function () {\n      var animEvt = null;\n      _this.panResponder = PanResponder.create({\n        onMoveShouldSetPanResponder: function onMoveShouldSetPanResponder(evt, gestureState) {\n          if (!_this.shouldPropagateSwipe(evt, gestureState)) {\n            var shouldSetPanResponder = Math.abs(gestureState.dx) >= _this.props.panResponderThreshold || Math.abs(gestureState.dy) >= _this.props.panResponderThreshold;\n\n            if (shouldSetPanResponder && _this.props.onSwipeStart) {\n              _this.props.onSwipeStart(gestureState);\n            }\n\n            _this.currentSwipingDirection = _this.getSwipingDirection(gestureState);\n            animEvt = _this.createAnimationEventForSwipe();\n            return shouldSetPanResponder;\n          }\n\n          return false;\n        },\n        onStartShouldSetPanResponder: function onStartShouldSetPanResponder(e, gestureState) {\n          var hasScrollableView = e._dispatchInstances && e._dispatchInstances.some(function (instance) {\n            return /scrollview|flatlist/i.test(instance.type);\n          });\n\n          if (hasScrollableView && _this.shouldPropagateSwipe(e, gestureState) && _this.props.scrollTo && _this.props.scrollOffset > 0) {\n            return false;\n          }\n\n          if (_this.props.onSwipeStart) {\n            _this.props.onSwipeStart(gestureState);\n          }\n\n          _this.currentSwipingDirection = null;\n          return true;\n        },\n        onPanResponderMove: function onPanResponderMove(evt, gestureState) {\n          if (!_this.currentSwipingDirection) {\n            if (gestureState.dx === 0 && gestureState.dy === 0) {\n              return;\n            }\n\n            _this.currentSwipingDirection = _this.getSwipingDirection(gestureState);\n            animEvt = _this.createAnimationEventForSwipe();\n          }\n\n          if (_this.isSwipeDirectionAllowed(gestureState)) {\n            var newOpacityFactor = 1 - _this.calcDistancePercentage(gestureState);\n\n            _this.backdropRef && _this.backdropRef.transitionTo({\n              opacity: _this.props.backdropOpacity * newOpacityFactor\n            });\n            animEvt(evt, gestureState);\n\n            if (_this.props.onSwipeMove) {\n              _this.props.onSwipeMove(newOpacityFactor, gestureState);\n            }\n          } else {\n            if (_this.props.scrollTo) {\n              if (_this.props.scrollHorizontal) {\n                var offsetX = -gestureState.dx;\n\n                if (offsetX > _this.props.scrollOffsetMax) {\n                  offsetX -= (offsetX - _this.props.scrollOffsetMax) / 2;\n                }\n\n                _this.props.scrollTo({\n                  x: offsetX,\n                  animated: false\n                });\n              } else {\n                var offsetY = -gestureState.dy;\n\n                if (offsetY > _this.props.scrollOffsetMax) {\n                  offsetY -= (offsetY - _this.props.scrollOffsetMax) / 2;\n                }\n\n                _this.props.scrollTo({\n                  y: offsetY,\n                  animated: false\n                });\n              }\n            }\n          }\n        },\n        onPanResponderRelease: function onPanResponderRelease(evt, gestureState) {\n          var accDistance = _this.getAccDistancePerDirection(gestureState);\n\n          if (accDistance > _this.props.swipeThreshold && _this.isSwipeDirectionAllowed(gestureState)) {\n            if (_this.props.onSwipeComplete) {\n              _this.inSwipeClosingState = true;\n\n              _this.props.onSwipeComplete({\n                swipingDirection: _this.getSwipingDirection(gestureState)\n              }, gestureState);\n\n              return;\n            }\n\n            if (_this.props.onSwipe) {\n              _this.inSwipeClosingState = true;\n\n              _this.props.onSwipe();\n\n              return;\n            }\n          }\n\n          if (_this.props.onSwipeCancel) {\n            _this.props.onSwipeCancel(gestureState);\n          }\n\n          if (_this.backdropRef) {\n            _this.backdropRef.transitionTo({\n              opacity: _this.props.backdropOpacity\n            });\n          }\n\n          Animated.spring(_this.state.pan, {\n            toValue: {\n              x: 0,\n              y: 0\n            },\n            bounciness: 0,\n            useNativeDriver: false\n          }).start();\n\n          if (_this.props.scrollTo) {\n            if (_this.props.scrollOffset > _this.props.scrollOffsetMax) {\n              _this.props.scrollTo({\n                y: _this.props.scrollOffsetMax,\n                animated: true\n              });\n            }\n          }\n        }\n      });\n    };\n\n    _this.getAccDistancePerDirection = function (gestureState) {\n      switch (_this.currentSwipingDirection) {\n        case 'up':\n          return -gestureState.dy;\n\n        case 'down':\n          return gestureState.dy;\n\n        case 'right':\n          return gestureState.dx;\n\n        case 'left':\n          return -gestureState.dx;\n\n        default:\n          return 0;\n      }\n    };\n\n    _this.getSwipingDirection = function (gestureState) {\n      if (Math.abs(gestureState.dx) > Math.abs(gestureState.dy)) {\n        return gestureState.dx > 0 ? 'right' : 'left';\n      }\n\n      return gestureState.dy > 0 ? 'down' : 'up';\n    };\n\n    _this.calcDistancePercentage = function (gestureState) {\n      switch (_this.currentSwipingDirection) {\n        case 'down':\n          return (gestureState.moveY - gestureState.y0) / ((_this.props.deviceHeight || _this.state.deviceHeight) - gestureState.y0);\n\n        case 'up':\n          return reversePercentage(gestureState.moveY / gestureState.y0);\n\n        case 'left':\n          return reversePercentage(gestureState.moveX / gestureState.x0);\n\n        case 'right':\n          return (gestureState.moveX - gestureState.x0) / ((_this.props.deviceWidth || _this.state.deviceWidth) - gestureState.x0);\n\n        default:\n          return 0;\n      }\n    };\n\n    _this.createAnimationEventForSwipe = function () {\n      if (_this.currentSwipingDirection === 'right' || _this.currentSwipingDirection === 'left') {\n        return Animated.event([null, {\n          dx: _this.state.pan.x\n        }], {\n          useNativeDriver: false\n        });\n      } else {\n        return Animated.event([null, {\n          dy: _this.state.pan.y\n        }], {\n          useNativeDriver: false\n        });\n      }\n    };\n\n    _this.isDirectionIncluded = function (direction) {\n      return Array.isArray(_this.props.swipeDirection) ? _this.props.swipeDirection.includes(direction) : _this.props.swipeDirection === direction;\n    };\n\n    _this.isSwipeDirectionAllowed = function (_ref) {\n      var dy = _ref.dy,\n          dx = _ref.dx;\n      var draggedDown = dy > 0;\n      var draggedUp = dy < 0;\n      var draggedLeft = dx < 0;\n      var draggedRight = dx > 0;\n\n      if (_this.currentSwipingDirection === 'up' && _this.isDirectionIncluded('up') && draggedUp) {\n        return true;\n      } else if (_this.currentSwipingDirection === 'down' && _this.isDirectionIncluded('down') && draggedDown) {\n        return true;\n      } else if (_this.currentSwipingDirection === 'right' && _this.isDirectionIncluded('right') && draggedRight) {\n        return true;\n      } else if (_this.currentSwipingDirection === 'left' && _this.isDirectionIncluded('left') && draggedLeft) {\n        return true;\n      }\n\n      return false;\n    };\n\n    _this.handleDimensionsUpdate = function () {\n      if (!_this.props.deviceHeight && !_this.props.deviceWidth) {\n        var deviceWidth = Dimensions.get('window').width;\n        var deviceHeight = Dimensions.get('window').height;\n\n        if (deviceWidth !== _this.state.deviceWidth || deviceHeight !== _this.state.deviceHeight) {\n          _this.setState({\n            deviceWidth: deviceWidth,\n            deviceHeight: deviceHeight\n          });\n        }\n      }\n    };\n\n    _this.open = function () {\n      if (_this.isTransitioning) {\n        return;\n      }\n\n      _this.isTransitioning = true;\n\n      if (_this.backdropRef) {\n        _this.backdropRef.transitionTo({\n          opacity: _this.props.backdropOpacity\n        }, _this.props.backdropTransitionInTiming);\n      }\n\n      if (_this.state.isSwipeable) {\n        _this.state.pan.setValue({\n          x: 0,\n          y: 0\n        });\n      }\n\n      if (_this.contentRef) {\n        _this.props.onModalWillShow && _this.props.onModalWillShow();\n        var interactionHandle = InteractionManager.createInteractionHandle();\n\n        _this.contentRef.animate(_this.animationIn, _this.props.animationInTiming).then(function () {\n          _this.isTransitioning = false;\n          InteractionManager.clearInteractionHandle(interactionHandle);\n\n          if (!_this.props.isVisible) {\n            _this.close();\n          } else {\n            _this.props.onModalShow();\n          }\n        });\n      }\n    };\n\n    _this.close = function () {\n      if (_this.isTransitioning) {\n        return;\n      }\n\n      _this.isTransitioning = true;\n\n      if (_this.backdropRef) {\n        _this.backdropRef.transitionTo({\n          opacity: 0\n        }, _this.props.backdropTransitionOutTiming);\n      }\n\n      var animationOut = _this.animationOut;\n\n      if (_this.inSwipeClosingState) {\n        _this.inSwipeClosingState = false;\n\n        if (_this.currentSwipingDirection === 'up') {\n          animationOut = 'slideOutUp';\n        } else if (_this.currentSwipingDirection === 'down') {\n          animationOut = 'slideOutDown';\n        } else if (_this.currentSwipingDirection === 'right') {\n          animationOut = 'slideOutRight';\n        } else if (_this.currentSwipingDirection === 'left') {\n          animationOut = 'slideOutLeft';\n        }\n      }\n\n      if (_this.contentRef) {\n        _this.props.onModalWillHide && _this.props.onModalWillHide();\n        var interactionHandle = InteractionManager.createInteractionHandle();\n\n        _this.contentRef.animate(animationOut, _this.props.animationOutTiming).then(function () {\n          _this.isTransitioning = false;\n          InteractionManager.clearInteractionHandle(interactionHandle);\n\n          if (_this.props.isVisible) {\n            _this.open();\n          } else {\n            _this.setState({\n              showContent: false\n            }, function () {\n              _this.setState({\n                isVisible: false\n              }, function () {\n                _this.props.onModalHide();\n              });\n            });\n          }\n        });\n      }\n    };\n\n    _this.makeBackdrop = function () {\n      if (!_this.props.hasBackdrop) {\n        return null;\n      }\n\n      if (_this.props.customBackdrop && !React.isValidElement(_this.props.customBackdrop)) {\n        console.warn('Invalid customBackdrop element passed to Modal. You must provide a valid React element.');\n      }\n\n      var _this$props = _this.props,\n          customBackdrop = _this$props.customBackdrop,\n          backdropColor = _this$props.backdropColor,\n          useNativeDriver = _this$props.useNativeDriver,\n          useNativeDriverForBackdrop = _this$props.useNativeDriverForBackdrop,\n          onBackdropPress = _this$props.onBackdropPress;\n      var hasCustomBackdrop = !!_this.props.customBackdrop;\n      var backdropComputedStyle = [{\n        width: _this.getDeviceWidth(),\n        height: _this.getDeviceHeight(),\n        backgroundColor: _this.state.showContent && !hasCustomBackdrop ? backdropColor : 'transparent'\n      }];\n      var backdropWrapper = React.createElement(animatable.View, {\n        ref: function ref(_ref2) {\n          return _this.backdropRef = _ref2;\n        },\n        useNativeDriver: useNativeDriverForBackdrop !== undefined ? useNativeDriverForBackdrop : useNativeDriver,\n        style: [styles.backdrop, backdropComputedStyle]\n      }, hasCustomBackdrop && customBackdrop);\n\n      if (hasCustomBackdrop) {\n        return backdropWrapper;\n      }\n\n      return React.createElement(TouchableWithoutFeedback, {\n        onPress: onBackdropPress\n      }, backdropWrapper);\n    };\n\n    var _buildAnimations = buildAnimations(extractAnimationFromProps(props)),\n        animationIn = _buildAnimations.animationIn,\n        animationOut = _buildAnimations.animationOut;\n\n    _this.animationIn = animationIn;\n    _this.animationOut = animationOut;\n\n    if (_this.state.isSwipeable) {\n      _this.state = _objectSpread(_objectSpread({}, _this.state), {}, {\n        pan: new Animated.ValueXY()\n      });\n\n      _this.buildPanResponder();\n    }\n\n    if (props.isVisible) {\n      _this.state = _objectSpread(_objectSpread({}, _this.state), {}, {\n        isVisible: true,\n        showContent: true\n      });\n    }\n\n    return _this;\n  }\n\n  _createClass(ReactNativeModal, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.onSwipe) {\n        console.warn('`<Modal onSwipe=\"...\" />` is deprecated and will be removed starting from 13.0.0. Use `<Modal onSwipeComplete=\"...\" />` instead.');\n      }\n\n      DeviceEventEmitter.addListener('didUpdateDimensions', this.handleDimensionsUpdate);\n\n      if (this.state.isVisible) {\n        this.open();\n      }\n\n      BackHandler.addEventListener('hardwareBackPress', this.onBackButtonPress);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      BackHandler.removeEventListener('hardwareBackPress', this.onBackButtonPress);\n      DeviceEventEmitter.removeListener('didUpdateDimensions', this.handleDimensionsUpdate);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (this.props.animationIn !== prevProps.animationIn || this.props.animationOut !== prevProps.animationOut) {\n        var _buildAnimations2 = buildAnimations(extractAnimationFromProps(this.props)),\n            animationIn = _buildAnimations2.animationIn,\n            animationOut = _buildAnimations2.animationOut;\n\n        this.animationIn = animationIn;\n        this.animationOut = animationOut;\n      }\n\n      if (this.props.backdropOpacity !== prevProps.backdropOpacity && this.backdropRef) {\n        this.backdropRef.transitionTo({\n          opacity: this.props.backdropOpacity\n        }, this.props.backdropTransitionInTiming);\n      }\n\n      if (this.props.isVisible && !prevProps.isVisible) {\n        this.open();\n      } else if (!this.props.isVisible && prevProps.isVisible) {\n        this.close();\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props2 = this.props,\n          animationIn = _this$props2.animationIn,\n          animationInTiming = _this$props2.animationInTiming,\n          animationOut = _this$props2.animationOut,\n          animationOutTiming = _this$props2.animationOutTiming,\n          avoidKeyboard = _this$props2.avoidKeyboard,\n          coverScreen = _this$props2.coverScreen,\n          hasBackdrop = _this$props2.hasBackdrop,\n          backdropColor = _this$props2.backdropColor,\n          backdropOpacity = _this$props2.backdropOpacity,\n          backdropTransitionInTiming = _this$props2.backdropTransitionInTiming,\n          backdropTransitionOutTiming = _this$props2.backdropTransitionOutTiming,\n          customBackdrop = _this$props2.customBackdrop,\n          children = _this$props2.children,\n          isVisible = _this$props2.isVisible,\n          onModalShow = _this$props2.onModalShow,\n          onBackButtonPress = _this$props2.onBackButtonPress,\n          useNativeDriver = _this$props2.useNativeDriver,\n          propagateSwipe = _this$props2.propagateSwipe,\n          style = _this$props2.style,\n          otherProps = _objectWithoutProperties(_this$props2, _excluded);\n\n      var testID = otherProps.testID,\n          containerProps = _objectWithoutProperties(otherProps, _excluded2);\n\n      var computedStyle = [{\n        margin: this.getDeviceWidth() * 0.05,\n        transform: [{\n          translateY: 0\n        }]\n      }, styles.content, style];\n      var panHandlers = {};\n      var panPosition = {};\n\n      if (this.state.isSwipeable) {\n        panHandlers = _objectSpread({}, this.panResponder.panHandlers);\n\n        if (useNativeDriver) {\n          panPosition = {\n            transform: this.state.pan.getTranslateTransform()\n          };\n        } else {\n          panPosition = this.state.pan.getLayout();\n        }\n      }\n\n      var _children = this.props.hideModalContentWhileAnimating && this.props.useNativeDriver && !this.state.showContent ? React.createElement(animatable.View, null) : children;\n\n      var containerView = React.createElement(animatable.View, _extends({}, panHandlers, {\n        ref: function ref(_ref3) {\n          return _this2.contentRef = _ref3;\n        },\n        style: [panPosition, computedStyle],\n        pointerEvents: \"box-none\",\n        useNativeDriver: useNativeDriver\n      }, containerProps), _children);\n\n      if (!coverScreen && this.state.isVisible) {\n        return React.createElement(View, {\n          pointerEvents: \"box-none\",\n          style: [styles.backdrop, styles.containerBox]\n        }, this.makeBackdrop(), containerView);\n      }\n\n      return React.createElement(Modal, _extends({\n        transparent: true,\n        animationType: 'none',\n        visible: this.state.isVisible,\n        onRequestClose: onBackButtonPress\n      }, otherProps), this.makeBackdrop(), avoidKeyboard ? React.createElement(KeyboardAvoidingView, {\n        behavior: Platform.OS === 'ios' ? 'padding' : undefined,\n        pointerEvents: \"box-none\",\n        style: computedStyle.concat([{\n          margin: 0\n        }])\n      }, containerView) : containerView);\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, state) {\n      if (!state.isVisible && nextProps.isVisible) {\n        return {\n          isVisible: true,\n          showContent: true\n        };\n      }\n\n      return null;\n    }\n  }]);\n\n  return ReactNativeModal;\n}(React.Component);\nReactNativeModal.propTypes = {\n  animationIn: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n  animationInTiming: PropTypes.number,\n  animationOut: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n  animationOutTiming: PropTypes.number,\n  avoidKeyboard: PropTypes.bool,\n  coverScreen: PropTypes.bool,\n  hasBackdrop: PropTypes.bool,\n  backdropColor: PropTypes.string,\n  backdropOpacity: PropTypes.number,\n  backdropTransitionInTiming: PropTypes.number,\n  backdropTransitionOutTiming: PropTypes.number,\n  customBackdrop: PropTypes.node,\n  children: PropTypes.node.isRequired,\n  deviceHeight: PropTypes.number,\n  deviceWidth: PropTypes.number,\n  isVisible: PropTypes.bool.isRequired,\n  hideModalContentWhileAnimating: PropTypes.bool,\n  propagateSwipe: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n  onModalShow: PropTypes.func,\n  onModalWillShow: PropTypes.func,\n  onModalHide: PropTypes.func,\n  onModalWillHide: PropTypes.func,\n  onBackButtonPress: PropTypes.func,\n  onBackdropPress: PropTypes.func,\n  panResponderThreshold: PropTypes.number,\n  onSwipeStart: PropTypes.func,\n  onSwipeMove: PropTypes.func,\n  onSwipeComplete: PropTypes.func,\n  onSwipeCancel: PropTypes.func,\n  swipeThreshold: PropTypes.number,\n  swipeDirection: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOf(['up', 'down', 'left', 'right'])), PropTypes.oneOf(['up', 'down', 'left', 'right'])]),\n  useNativeDriver: PropTypes.bool,\n  useNativeDriverForBackdrop: PropTypes.bool,\n  style: PropTypes.any,\n  scrollTo: PropTypes.func,\n  scrollOffset: PropTypes.number,\n  scrollOffsetMax: PropTypes.number,\n  scrollHorizontal: PropTypes.bool,\n  supportedOrientations: PropTypes.arrayOf(PropTypes.oneOf(['portrait', 'portrait-upside-down', 'landscape', 'landscape-left', 'landscape-right']))\n};\nReactNativeModal.defaultProps = {\n  animationIn: 'slideInUp',\n  animationInTiming: 300,\n  animationOut: 'slideOutDown',\n  animationOutTiming: 300,\n  avoidKeyboard: false,\n  coverScreen: true,\n  hasBackdrop: true,\n  backdropColor: 'black',\n  backdropOpacity: 0.7,\n  backdropTransitionInTiming: 300,\n  backdropTransitionOutTiming: 300,\n  customBackdrop: null,\n  useNativeDriver: false,\n  deviceHeight: null,\n  deviceWidth: null,\n  hideModalContentWhileAnimating: false,\n  propagateSwipe: false,\n  isVisible: false,\n  onModalShow: function onModalShow() {\n    return null;\n  },\n  onModalWillShow: function onModalWillShow() {\n    return null;\n  },\n  onModalHide: function onModalHide() {\n    return null;\n  },\n  onModalWillHide: function onModalWillHide() {\n    return null;\n  },\n  onBackdropPress: function onBackdropPress() {\n    return null;\n  },\n  onBackButtonPress: function onBackButtonPress() {\n    return null;\n  },\n  panResponderThreshold: 4,\n  swipeThreshold: 100,\n  scrollTo: null,\n  scrollOffset: 0,\n  scrollOffsetMax: 0,\n  scrollHorizontal: false,\n  supportedOrientations: ['portrait', 'landscape']\n};\nexport default ReactNativeModal;","map":{"version":3,"names":["React","PropTypes","animatable","initializeAnimations","buildAnimations","reversePercentage","styles","extractAnimationFromProps","props","animationIn","animationOut","ReactNativeModal","state","showContent","isVisible","deviceWidth","Dimensions","get","width","deviceHeight","height","isSwipeable","swipeDirection","pan","isTransitioning","inSwipeClosingState","currentSwipingDirection","panResponder","getDeviceHeight","getDeviceWidth","onBackButtonPress","shouldPropagateSwipe","evt","gestureState","propagateSwipe","buildPanResponder","animEvt","PanResponder","create","onMoveShouldSetPanResponder","shouldSetPanResponder","Math","abs","dx","panResponderThreshold","dy","onSwipeStart","getSwipingDirection","createAnimationEventForSwipe","onStartShouldSetPanResponder","e","hasScrollableView","_dispatchInstances","some","instance","test","type","scrollTo","scrollOffset","onPanResponderMove","isSwipeDirectionAllowed","newOpacityFactor","calcDistancePercentage","backdropRef","transitionTo","opacity","backdropOpacity","onSwipeMove","scrollHorizontal","offsetX","scrollOffsetMax","x","animated","offsetY","y","onPanResponderRelease","accDistance","getAccDistancePerDirection","swipeThreshold","onSwipeComplete","swipingDirection","onSwipe","onSwipeCancel","Animated","spring","toValue","bounciness","useNativeDriver","start","moveY","y0","moveX","x0","event","isDirectionIncluded","direction","Array","isArray","includes","draggedDown","draggedUp","draggedLeft","draggedRight","handleDimensionsUpdate","setState","open","backdropTransitionInTiming","setValue","contentRef","onModalWillShow","interactionHandle","InteractionManager","createInteractionHandle","animate","animationInTiming","then","clearInteractionHandle","close","onModalShow","backdropTransitionOutTiming","onModalWillHide","animationOutTiming","onModalHide","makeBackdrop","hasBackdrop","customBackdrop","isValidElement","console","warn","backdropColor","useNativeDriverForBackdrop","onBackdropPress","hasCustomBackdrop","backdropComputedStyle","backgroundColor","backdropWrapper","createElement","View","ref","undefined","style","backdrop","TouchableWithoutFeedback","onPress","ValueXY","DeviceEventEmitter","addListener","BackHandler","addEventListener","removeEventListener","removeListener","prevProps","avoidKeyboard","coverScreen","children","otherProps","testID","containerProps","computedStyle","margin","transform","translateY","content","panHandlers","panPosition","getTranslateTransform","getLayout","_children","hideModalContentWhileAnimating","containerView","pointerEvents","containerBox","Modal","transparent","animationType","visible","onRequestClose","KeyboardAvoidingView","behavior","Platform","OS","concat","nextProps","Component","propTypes","oneOfType","string","object","number","bool","node","isRequired","func","arrayOf","oneOf","any","supportedOrientations","defaultProps"],"sources":["I:/Workspace/mediWS/mccWS/frontend-clinic-app/node_modules/react-native-modal/dist/modal.js"],"sourcesContent":["import * as React from 'react';\nimport { Animated, DeviceEventEmitter, Dimensions, InteractionManager, KeyboardAvoidingView, Modal, PanResponder, BackHandler, Platform, TouchableWithoutFeedback, View, } from 'react-native';\nimport * as PropTypes from 'prop-types';\nimport * as animatable from 'react-native-animatable';\nimport { initializeAnimations, buildAnimations, reversePercentage, } from './utils';\nimport styles from './modal.style';\n// Override default react-native-animatable animations\ninitializeAnimations();\nconst extractAnimationFromProps = (props) => ({\n    animationIn: props.animationIn,\n    animationOut: props.animationOut,\n});\nexport class ReactNativeModal extends React.Component {\n    constructor(props) {\n        super(props);\n        // We use an internal state for keeping track of the modal visibility: this allows us to keep\n        // the modal visible during the exit animation, even if the user has already change the\n        // isVisible prop to false.\n        // We store in the state the device width and height so that we can update the modal on\n        // device rotation.\n        this.state = {\n            showContent: true,\n            isVisible: false,\n            deviceWidth: Dimensions.get('window').width,\n            deviceHeight: Dimensions.get('window').height,\n            isSwipeable: !!this.props.swipeDirection,\n            pan: null,\n        };\n        this.isTransitioning = false;\n        this.inSwipeClosingState = false;\n        this.currentSwipingDirection = null;\n        this.panResponder = null;\n        this.getDeviceHeight = () => this.props.deviceHeight || this.state.deviceHeight;\n        this.getDeviceWidth = () => this.props.deviceWidth || this.state.deviceWidth;\n        this.onBackButtonPress = () => {\n            if (this.props.onBackButtonPress && this.props.isVisible) {\n                this.props.onBackButtonPress();\n                return true;\n            }\n            return false;\n        };\n        this.shouldPropagateSwipe = (evt, gestureState) => {\n            return typeof this.props.propagateSwipe === 'function'\n                ? this.props.propagateSwipe(evt, gestureState)\n                : this.props.propagateSwipe;\n        };\n        this.buildPanResponder = () => {\n            let animEvt = null;\n            this.panResponder = PanResponder.create({\n                onMoveShouldSetPanResponder: (evt, gestureState) => {\n                    // Use propagateSwipe to allow inner content to scroll. See PR:\n                    // https://github.com/react-native-community/react-native-modal/pull/246\n                    if (!this.shouldPropagateSwipe(evt, gestureState)) {\n                        // The number \"4\" is just a good tradeoff to make the panResponder\n                        // work correctly even when the modal has touchable buttons.\n                        // However, if you want to overwrite this and choose for yourself,\n                        // set panResponderThreshold in the props.\n                        // For reference:\n                        // https://github.com/react-native-community/react-native-modal/pull/197\n                        const shouldSetPanResponder = Math.abs(gestureState.dx) >= this.props.panResponderThreshold ||\n                            Math.abs(gestureState.dy) >= this.props.panResponderThreshold;\n                        if (shouldSetPanResponder && this.props.onSwipeStart) {\n                            this.props.onSwipeStart(gestureState);\n                        }\n                        this.currentSwipingDirection = this.getSwipingDirection(gestureState);\n                        animEvt = this.createAnimationEventForSwipe();\n                        return shouldSetPanResponder;\n                    }\n                    return false;\n                },\n                onStartShouldSetPanResponder: (e, gestureState) => {\n                    const hasScrollableView = e._dispatchInstances &&\n                        e._dispatchInstances.some((instance) => /scrollview|flatlist/i.test(instance.type));\n                    if (hasScrollableView &&\n                        this.shouldPropagateSwipe(e, gestureState) &&\n                        this.props.scrollTo &&\n                        this.props.scrollOffset > 0) {\n                        return false; // user needs to be able to scroll content back up\n                    }\n                    if (this.props.onSwipeStart) {\n                        this.props.onSwipeStart(gestureState);\n                    }\n                    // Cleared so that onPanResponderMove can wait to have some delta\n                    // to work with\n                    this.currentSwipingDirection = null;\n                    return true;\n                },\n                onPanResponderMove: (evt, gestureState) => {\n                    // Using onStartShouldSetPanResponder we don't have any delta so we don't know\n                    // The direction to which the user is swiping until some move have been done\n                    if (!this.currentSwipingDirection) {\n                        if (gestureState.dx === 0 && gestureState.dy === 0) {\n                            return;\n                        }\n                        this.currentSwipingDirection = this.getSwipingDirection(gestureState);\n                        animEvt = this.createAnimationEventForSwipe();\n                    }\n                    if (this.isSwipeDirectionAllowed(gestureState)) {\n                        // Dim the background while swiping the modal\n                        const newOpacityFactor = 1 - this.calcDistancePercentage(gestureState);\n                        this.backdropRef &&\n                            this.backdropRef.transitionTo({\n                                opacity: this.props.backdropOpacity * newOpacityFactor,\n                            });\n                        animEvt(evt, gestureState);\n                        if (this.props.onSwipeMove) {\n                            this.props.onSwipeMove(newOpacityFactor, gestureState);\n                        }\n                    }\n                    else {\n                        if (this.props.scrollTo) {\n                            if (this.props.scrollHorizontal) {\n                                let offsetX = -gestureState.dx;\n                                if (offsetX > this.props.scrollOffsetMax) {\n                                    offsetX -= (offsetX - this.props.scrollOffsetMax) / 2;\n                                }\n                                this.props.scrollTo({ x: offsetX, animated: false });\n                            }\n                            else {\n                                let offsetY = -gestureState.dy;\n                                if (offsetY > this.props.scrollOffsetMax) {\n                                    offsetY -= (offsetY - this.props.scrollOffsetMax) / 2;\n                                }\n                                this.props.scrollTo({ y: offsetY, animated: false });\n                            }\n                        }\n                    }\n                },\n                onPanResponderRelease: (evt, gestureState) => {\n                    // Call the onSwipe prop if the threshold has been exceeded on the right direction\n                    const accDistance = this.getAccDistancePerDirection(gestureState);\n                    if (accDistance > this.props.swipeThreshold &&\n                        this.isSwipeDirectionAllowed(gestureState)) {\n                        if (this.props.onSwipeComplete) {\n                            this.inSwipeClosingState = true;\n                            this.props.onSwipeComplete({\n                                swipingDirection: this.getSwipingDirection(gestureState),\n                            }, gestureState);\n                            return;\n                        }\n                        // Deprecated. Remove later.\n                        if (this.props.onSwipe) {\n                            this.inSwipeClosingState = true;\n                            this.props.onSwipe();\n                            return;\n                        }\n                    }\n                    //Reset backdrop opacity and modal position\n                    if (this.props.onSwipeCancel) {\n                        this.props.onSwipeCancel(gestureState);\n                    }\n                    if (this.backdropRef) {\n                        this.backdropRef.transitionTo({\n                            opacity: this.props.backdropOpacity,\n                        });\n                    }\n                    Animated.spring(this.state.pan, {\n                        toValue: { x: 0, y: 0 },\n                        bounciness: 0,\n                        useNativeDriver: false,\n                    }).start();\n                    if (this.props.scrollTo) {\n                        if (this.props.scrollOffset > this.props.scrollOffsetMax) {\n                            this.props.scrollTo({\n                                y: this.props.scrollOffsetMax,\n                                animated: true,\n                            });\n                        }\n                    }\n                },\n            });\n        };\n        this.getAccDistancePerDirection = (gestureState) => {\n            switch (this.currentSwipingDirection) {\n                case 'up':\n                    return -gestureState.dy;\n                case 'down':\n                    return gestureState.dy;\n                case 'right':\n                    return gestureState.dx;\n                case 'left':\n                    return -gestureState.dx;\n                default:\n                    return 0;\n            }\n        };\n        this.getSwipingDirection = (gestureState) => {\n            if (Math.abs(gestureState.dx) > Math.abs(gestureState.dy)) {\n                return gestureState.dx > 0 ? 'right' : 'left';\n            }\n            return gestureState.dy > 0 ? 'down' : 'up';\n        };\n        this.calcDistancePercentage = (gestureState) => {\n            switch (this.currentSwipingDirection) {\n                case 'down':\n                    return ((gestureState.moveY - gestureState.y0) /\n                        ((this.props.deviceHeight || this.state.deviceHeight) -\n                            gestureState.y0));\n                case 'up':\n                    return reversePercentage(gestureState.moveY / gestureState.y0);\n                case 'left':\n                    return reversePercentage(gestureState.moveX / gestureState.x0);\n                case 'right':\n                    return ((gestureState.moveX - gestureState.x0) /\n                        ((this.props.deviceWidth || this.state.deviceWidth) - gestureState.x0));\n                default:\n                    return 0;\n            }\n        };\n        this.createAnimationEventForSwipe = () => {\n            if (this.currentSwipingDirection === 'right' ||\n                this.currentSwipingDirection === 'left') {\n                return Animated.event([null, { dx: this.state.pan.x }], {\n                    useNativeDriver: false,\n                });\n            }\n            else {\n                return Animated.event([null, { dy: this.state.pan.y }], {\n                    useNativeDriver: false,\n                });\n            }\n        };\n        this.isDirectionIncluded = (direction) => {\n            return Array.isArray(this.props.swipeDirection)\n                ? this.props.swipeDirection.includes(direction)\n                : this.props.swipeDirection === direction;\n        };\n        this.isSwipeDirectionAllowed = ({ dy, dx }) => {\n            const draggedDown = dy > 0;\n            const draggedUp = dy < 0;\n            const draggedLeft = dx < 0;\n            const draggedRight = dx > 0;\n            if (this.currentSwipingDirection === 'up' &&\n                this.isDirectionIncluded('up') &&\n                draggedUp) {\n                return true;\n            }\n            else if (this.currentSwipingDirection === 'down' &&\n                this.isDirectionIncluded('down') &&\n                draggedDown) {\n                return true;\n            }\n            else if (this.currentSwipingDirection === 'right' &&\n                this.isDirectionIncluded('right') &&\n                draggedRight) {\n                return true;\n            }\n            else if (this.currentSwipingDirection === 'left' &&\n                this.isDirectionIncluded('left') &&\n                draggedLeft) {\n                return true;\n            }\n            return false;\n        };\n        this.handleDimensionsUpdate = () => {\n            if (!this.props.deviceHeight && !this.props.deviceWidth) {\n                // Here we update the device dimensions in the state if the layout changed\n                // (triggering a render)\n                const deviceWidth = Dimensions.get('window').width;\n                const deviceHeight = Dimensions.get('window').height;\n                if (deviceWidth !== this.state.deviceWidth ||\n                    deviceHeight !== this.state.deviceHeight) {\n                    this.setState({ deviceWidth, deviceHeight });\n                }\n            }\n        };\n        this.open = () => {\n            if (this.isTransitioning) {\n                return;\n            }\n            this.isTransitioning = true;\n            if (this.backdropRef) {\n                this.backdropRef.transitionTo({ opacity: this.props.backdropOpacity }, this.props.backdropTransitionInTiming);\n            }\n            // This is for resetting the pan position,otherwise the modal gets stuck\n            // at the last released position when you try to open it.\n            // TODO: Could certainly be improved - no idea for the moment.\n            if (this.state.isSwipeable) {\n                this.state.pan.setValue({ x: 0, y: 0 });\n            }\n            if (this.contentRef) {\n                this.props.onModalWillShow && this.props.onModalWillShow();\n                const interactionHandle = InteractionManager.createInteractionHandle();\n                this.contentRef\n                    .animate(this.animationIn, this.props.animationInTiming)\n                    .then(() => {\n                    this.isTransitioning = false;\n                    InteractionManager.clearInteractionHandle(interactionHandle);\n                    if (!this.props.isVisible) {\n                        this.close();\n                    }\n                    else {\n                        this.props.onModalShow();\n                    }\n                });\n            }\n        };\n        this.close = () => {\n            if (this.isTransitioning) {\n                return;\n            }\n            this.isTransitioning = true;\n            if (this.backdropRef) {\n                this.backdropRef.transitionTo({ opacity: 0 }, this.props.backdropTransitionOutTiming);\n            }\n            let animationOut = this.animationOut;\n            if (this.inSwipeClosingState) {\n                this.inSwipeClosingState = false;\n                if (this.currentSwipingDirection === 'up') {\n                    animationOut = 'slideOutUp';\n                }\n                else if (this.currentSwipingDirection === 'down') {\n                    animationOut = 'slideOutDown';\n                }\n                else if (this.currentSwipingDirection === 'right') {\n                    animationOut = 'slideOutRight';\n                }\n                else if (this.currentSwipingDirection === 'left') {\n                    animationOut = 'slideOutLeft';\n                }\n            }\n            if (this.contentRef) {\n                this.props.onModalWillHide && this.props.onModalWillHide();\n                const interactionHandle = InteractionManager.createInteractionHandle();\n                this.contentRef\n                    .animate(animationOut, this.props.animationOutTiming)\n                    .then(() => {\n                    this.isTransitioning = false;\n                    InteractionManager.clearInteractionHandle(interactionHandle);\n                    if (this.props.isVisible) {\n                        this.open();\n                    }\n                    else {\n                        this.setState({\n                            showContent: false,\n                        }, () => {\n                            this.setState({\n                                isVisible: false,\n                            }, () => {\n                                this.props.onModalHide();\n                            });\n                        });\n                    }\n                });\n            }\n        };\n        this.makeBackdrop = () => {\n            if (!this.props.hasBackdrop) {\n                return null;\n            }\n            if (this.props.customBackdrop &&\n                !React.isValidElement(this.props.customBackdrop)) {\n                console.warn('Invalid customBackdrop element passed to Modal. You must provide a valid React element.');\n            }\n            const { customBackdrop, backdropColor, useNativeDriver, useNativeDriverForBackdrop, onBackdropPress, } = this.props;\n            const hasCustomBackdrop = !!this.props.customBackdrop;\n            const backdropComputedStyle = [\n                {\n                    width: this.getDeviceWidth(),\n                    height: this.getDeviceHeight(),\n                    backgroundColor: this.state.showContent && !hasCustomBackdrop\n                        ? backdropColor\n                        : 'transparent',\n                },\n            ];\n            const backdropWrapper = (React.createElement(animatable.View, { ref: ref => (this.backdropRef = ref), useNativeDriver: useNativeDriverForBackdrop !== undefined\n                    ? useNativeDriverForBackdrop\n                    : useNativeDriver, style: [styles.backdrop, backdropComputedStyle] }, hasCustomBackdrop && customBackdrop));\n            if (hasCustomBackdrop) {\n                // The user will handle backdrop presses himself\n                return backdropWrapper;\n            }\n            // If there's no custom backdrop, handle presses with\n            // TouchableWithoutFeedback\n            return (React.createElement(TouchableWithoutFeedback, { onPress: onBackdropPress }, backdropWrapper));\n        };\n        const { animationIn, animationOut } = buildAnimations(extractAnimationFromProps(props));\n        this.animationIn = animationIn;\n        this.animationOut = animationOut;\n        if (this.state.isSwipeable) {\n            this.state = {\n                ...this.state,\n                pan: new Animated.ValueXY(),\n            };\n            this.buildPanResponder();\n        }\n        if (props.isVisible) {\n            this.state = {\n                ...this.state,\n                isVisible: true,\n                showContent: true,\n            };\n        }\n    }\n    static getDerivedStateFromProps(nextProps, state) {\n        if (!state.isVisible && nextProps.isVisible) {\n            return { isVisible: true, showContent: true };\n        }\n        return null;\n    }\n    componentDidMount() {\n        // Show deprecation message\n        if (this.props.onSwipe) {\n            console.warn('`<Modal onSwipe=\"...\" />` is deprecated and will be removed starting from 13.0.0. Use `<Modal onSwipeComplete=\"...\" />` instead.');\n        }\n        DeviceEventEmitter.addListener('didUpdateDimensions', this.handleDimensionsUpdate);\n        if (this.state.isVisible) {\n            this.open();\n        }\n        BackHandler.addEventListener('hardwareBackPress', this.onBackButtonPress);\n    }\n    componentWillUnmount() {\n        BackHandler.removeEventListener('hardwareBackPress', this.onBackButtonPress);\n        DeviceEventEmitter.removeListener('didUpdateDimensions', this.handleDimensionsUpdate);\n    }\n    componentDidUpdate(prevProps) {\n        // If the animations have been changed then rebuild them to make sure we're\n        // using the most up-to-date ones\n        if (this.props.animationIn !== prevProps.animationIn ||\n            this.props.animationOut !== prevProps.animationOut) {\n            const { animationIn, animationOut } = buildAnimations(extractAnimationFromProps(this.props));\n            this.animationIn = animationIn;\n            this.animationOut = animationOut;\n        }\n        // If backdrop opacity has been changed then make sure to update it\n        if (this.props.backdropOpacity !== prevProps.backdropOpacity &&\n            this.backdropRef) {\n            this.backdropRef.transitionTo({ opacity: this.props.backdropOpacity }, this.props.backdropTransitionInTiming);\n        }\n        // On modal open request, we slide the view up and fade in the backdrop\n        if (this.props.isVisible && !prevProps.isVisible) {\n            this.open();\n        }\n        else if (!this.props.isVisible && prevProps.isVisible) {\n            // On modal close request, we slide the view down and fade out the backdrop\n            this.close();\n        }\n    }\n    render() {\n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        const { animationIn, animationInTiming, animationOut, animationOutTiming, avoidKeyboard, coverScreen, hasBackdrop, backdropColor, backdropOpacity, backdropTransitionInTiming, backdropTransitionOutTiming, customBackdrop, children, isVisible, onModalShow, onBackButtonPress, useNativeDriver, propagateSwipe, style, ...otherProps } = this.props;\n        const { testID, ...containerProps } = otherProps;\n        const computedStyle = [\n            { margin: this.getDeviceWidth() * 0.05, transform: [{ translateY: 0 }] },\n            styles.content,\n            style,\n        ];\n        let panHandlers = {};\n        let panPosition = {};\n        if (this.state.isSwipeable) {\n            panHandlers = { ...this.panResponder.panHandlers };\n            if (useNativeDriver) {\n                panPosition = {\n                    transform: this.state.pan.getTranslateTransform(),\n                };\n            }\n            else {\n                panPosition = this.state.pan.getLayout();\n            }\n        }\n        // The user might decide not to show the modal while it is animating\n        // to enhance performance.\n        const _children = this.props.hideModalContentWhileAnimating &&\n            this.props.useNativeDriver &&\n            !this.state.showContent ? (React.createElement(animatable.View, null)) : (children);\n        const containerView = (React.createElement(animatable.View, Object.assign({}, panHandlers, { ref: ref => (this.contentRef = ref), style: [panPosition, computedStyle], pointerEvents: \"box-none\", useNativeDriver: useNativeDriver }, containerProps), _children));\n        // If coverScreen is set to false by the user\n        // we render the modal inside the parent view directly\n        if (!coverScreen && this.state.isVisible) {\n            return (React.createElement(View, { pointerEvents: \"box-none\", style: [styles.backdrop, styles.containerBox] },\n                this.makeBackdrop(),\n                containerView));\n        }\n        return (React.createElement(Modal, Object.assign({ transparent: true, animationType: 'none', visible: this.state.isVisible, onRequestClose: onBackButtonPress }, otherProps),\n            this.makeBackdrop(),\n            avoidKeyboard ? (React.createElement(KeyboardAvoidingView, { behavior: Platform.OS === 'ios' ? 'padding' : undefined, pointerEvents: \"box-none\", style: computedStyle.concat([{ margin: 0 }]) }, containerView)) : (containerView)));\n    }\n}\nReactNativeModal.propTypes = {\n    animationIn: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n    animationInTiming: PropTypes.number,\n    animationOut: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n    animationOutTiming: PropTypes.number,\n    avoidKeyboard: PropTypes.bool,\n    coverScreen: PropTypes.bool,\n    hasBackdrop: PropTypes.bool,\n    backdropColor: PropTypes.string,\n    backdropOpacity: PropTypes.number,\n    backdropTransitionInTiming: PropTypes.number,\n    backdropTransitionOutTiming: PropTypes.number,\n    customBackdrop: PropTypes.node,\n    children: PropTypes.node.isRequired,\n    deviceHeight: PropTypes.number,\n    deviceWidth: PropTypes.number,\n    isVisible: PropTypes.bool.isRequired,\n    hideModalContentWhileAnimating: PropTypes.bool,\n    propagateSwipe: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),\n    onModalShow: PropTypes.func,\n    onModalWillShow: PropTypes.func,\n    onModalHide: PropTypes.func,\n    onModalWillHide: PropTypes.func,\n    onBackButtonPress: PropTypes.func,\n    onBackdropPress: PropTypes.func,\n    panResponderThreshold: PropTypes.number,\n    onSwipeStart: PropTypes.func,\n    onSwipeMove: PropTypes.func,\n    onSwipeComplete: PropTypes.func,\n    onSwipeCancel: PropTypes.func,\n    swipeThreshold: PropTypes.number,\n    swipeDirection: PropTypes.oneOfType([\n        PropTypes.arrayOf(PropTypes.oneOf(['up', 'down', 'left', 'right'])),\n        PropTypes.oneOf(['up', 'down', 'left', 'right']),\n    ]),\n    useNativeDriver: PropTypes.bool,\n    useNativeDriverForBackdrop: PropTypes.bool,\n    style: PropTypes.any,\n    scrollTo: PropTypes.func,\n    scrollOffset: PropTypes.number,\n    scrollOffsetMax: PropTypes.number,\n    scrollHorizontal: PropTypes.bool,\n    supportedOrientations: PropTypes.arrayOf(PropTypes.oneOf([\n        'portrait',\n        'portrait-upside-down',\n        'landscape',\n        'landscape-left',\n        'landscape-right',\n    ])),\n};\nReactNativeModal.defaultProps = {\n    animationIn: 'slideInUp',\n    animationInTiming: 300,\n    animationOut: 'slideOutDown',\n    animationOutTiming: 300,\n    avoidKeyboard: false,\n    coverScreen: true,\n    hasBackdrop: true,\n    backdropColor: 'black',\n    backdropOpacity: 0.7,\n    backdropTransitionInTiming: 300,\n    backdropTransitionOutTiming: 300,\n    customBackdrop: null,\n    useNativeDriver: false,\n    deviceHeight: null,\n    deviceWidth: null,\n    hideModalContentWhileAnimating: false,\n    propagateSwipe: false,\n    isVisible: false,\n    onModalShow: () => null,\n    onModalWillShow: () => null,\n    onModalHide: () => null,\n    onModalWillHide: () => null,\n    onBackdropPress: () => null,\n    onBackButtonPress: () => null,\n    panResponderThreshold: 4,\n    swipeThreshold: 100,\n    scrollTo: null,\n    scrollOffset: 0,\n    scrollOffsetMax: 0,\n    scrollHorizontal: false,\n    supportedOrientations: ['portrait', 'landscape'],\n};\nexport default ReactNativeModal;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}