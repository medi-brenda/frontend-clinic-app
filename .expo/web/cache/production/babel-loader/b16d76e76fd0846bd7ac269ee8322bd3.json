{"ast":null,"code":"import _slicedToArray from\"@babel/runtime/helpers/slicedToArray\";import{useEffect,useLayoutEffect,useState}from'react';import{addNotificationResponseReceivedListener}from\"./NotificationsEmitter\";import NotificationsEmitterModule from\"./NotificationsEmitterModule\";export default function useLastNotificationResponse(){var _useState=useState(undefined),_useState2=_slicedToArray(_useState,2),lastNotificationResponse=_useState2[0],setLastNotificationResponse=_useState2[1];useLayoutEffect(function(){var subscription=addNotificationResponseReceivedListener(function(response){setLastNotificationResponse(response);});return function(){subscription.remove();};},[]);useEffect(function(){NotificationsEmitterModule.getLastNotificationResponseAsync==null?void 0:NotificationsEmitterModule.getLastNotificationResponseAsync().then(function(response){setLastNotificationResponse(function(currentResponse){return currentResponse!=null?currentResponse:response;});});},[]);return lastNotificationResponse;}","map":{"version":3,"sources":["../src/useLastNotificationResponse.ts"],"names":[],"mappings":"iEAAA,OAAS,SAAT,CAAoB,eAApB,CAAqC,QAArC,KAAqD,OAArD,CAGA,OAAS,uCAAT,8BACA,MAAO,CAAA,0BAAP,oCASA,cAAc,SAAU,CAAA,2BAAV,EAAqC,CACjD,cAAgE,QAAQ,CAEtE,SAFsE,CAAxE,wCAAO,wBAAP,eAAiC,2BAAjC,eAKA,eAAe,CAAC,UAAK,CACnB,GAAM,CAAA,YAAY,CAAG,uCAAuC,CAAC,SAAC,QAAD,CAAa,CACxE,2BAA2B,CAAC,QAAD,CAA3B,CACD,CAF2D,CAA5D,CAGA,MAAO,WAAK,CACV,YAAY,CAAC,MAAb,GACD,CAFD,CAGD,CAPc,CAOZ,EAPY,CAAf,CAYA,SAAS,CAAC,UAAK,CACb,0BAA0B,CAAC,gCAA3B,cAAA,0BAA0B,CAAC,gCAA3B,GAAgE,IAAhE,CAAqE,SAAC,QAAD,CAAa,CAIhF,2BAA2B,CAAC,SAAC,eAAD,QAAqB,CAAA,eAArB,OAAqB,eAArB,CAAwC,QAAxC,EAAD,CAA3B,CACD,CALD,EAMD,CAPQ,CAON,EAPM,CAAT,CASA,MAAO,CAAA,wBAAP,CACD","sourcesContent":["import { useEffect, useLayoutEffect, useState } from 'react';\n\nimport { NotificationResponse } from './Notifications.types';\nimport { addNotificationResponseReceivedListener } from './NotificationsEmitter';\nimport NotificationsEmitterModule from './NotificationsEmitterModule';\n\n/**\n * Return value of this hook may be one of three types:\n * - `undefined` until we know what to return\n * - `null` until the app receives any notification response\n * - an object of `NotificationResponse` type - the response\n *   that has been received by the app most recently.\n */\nexport default function useLastNotificationResponse() {\n  const [lastNotificationResponse, setLastNotificationResponse] = useState<\n    NotificationResponse | null | undefined\n  >(undefined);\n\n  // useLayoutEffect ensures the listener is registered as soon as possible\n  useLayoutEffect(() => {\n    const subscription = addNotificationResponseReceivedListener((response) => {\n      setLastNotificationResponse(response);\n    });\n    return () => {\n      subscription.remove();\n    };\n  }, []);\n\n  // On each mount of this hook we fetch last notification response\n  // from the native module which is an \"always active listener\"\n  // and always returns the most recent response.\n  useEffect(() => {\n    NotificationsEmitterModule.getLastNotificationResponseAsync?.().then((response) => {\n      // We only update the state with the resolved value if it's empty,\n      // because if it's not empty it must have been populated by the `useLayoutEffect`\n      // listener which returns \"live\" values.\n      setLastNotificationResponse((currentResponse) => currentResponse ?? response);\n    });\n  }, []);\n\n  return lastNotificationResponse;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}