{"ast":null,"code":"import _regeneratorRuntime from\"@babel/runtime/regenerator\";import{PermissionStatus,Platform}from'expo-modules-core';function convertPermissionStatus(status){switch(status){case'granted':return{status:PermissionStatus.GRANTED,expires:'never',canAskAgain:false,granted:true};case'denied':return{status:PermissionStatus.DENIED,expires:'never',canAskAgain:false,granted:false};default:return{status:PermissionStatus.UNDETERMINED,expires:'never',canAskAgain:true,granted:false};}}function resolvePermissionAsync(_ref){var _navigator,_navigator$permission;var shouldAsk,_window,_window$Notification,Notification,status,query;return _regeneratorRuntime.async(function resolvePermissionAsync$(_context){while(1){switch(_context.prev=_context.next){case 0:shouldAsk=_ref.shouldAsk;if(Platform.isDOMAvailable){_context.next=3;break;}return _context.abrupt(\"return\",convertPermissionStatus('denied'));case 3:_window=window,_window$Notification=_window.Notification,Notification=_window$Notification===void 0?{}:_window$Notification;if(!(typeof Notification.requestPermission!=='undefined')){_context.next=13;break;}status=Notification.permission;if(!shouldAsk){_context.next=10;break;}_context.next=9;return _regeneratorRuntime.awrap(new Promise(function(resolve,reject){var _Notification$request,_Notification$request2;var resolved=false;function resolveOnce(status){if(!resolved){resolved=true;resolve(status);}}(_Notification$request=Notification.requestPermission(resolveOnce))==null?void 0:(_Notification$request2=_Notification$request.then(resolveOnce))==null?void 0:_Notification$request2.catch(reject);}));case 9:status=_context.sent;case 10:return _context.abrupt(\"return\",convertPermissionStatus(status));case 13:if(!(typeof navigator!=='undefined'&&(_navigator=navigator)!=null&&(_navigator$permission=_navigator.permissions)!=null&&_navigator$permission.query)){_context.next=18;break;}_context.next=16;return _regeneratorRuntime.awrap(navigator.permissions.query({name:'notifications'}));case 16:query=_context.sent;return _context.abrupt(\"return\",convertPermissionStatus(query.state));case 18:return _context.abrupt(\"return\",convertPermissionStatus('denied'));case 19:case\"end\":return _context.stop();}}},null,null,null,Promise);}export default{addListener:function addListener(){},removeListeners:function removeListeners(){},getPermissionsAsync:function getPermissionsAsync(){return function _callee(){return _regeneratorRuntime.async(function _callee$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:return _context2.abrupt(\"return\",resolvePermissionAsync({shouldAsk:false}));case 1:case\"end\":return _context2.stop();}}},null,null,null,Promise);}();},requestPermissionsAsync:function requestPermissionsAsync(request){return function _callee2(){return _regeneratorRuntime.async(function _callee2$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:return _context3.abrupt(\"return\",resolvePermissionAsync({shouldAsk:true}));case 1:case\"end\":return _context3.stop();}}},null,null,null,Promise);}();}};","map":{"version":3,"sources":["../src/NotificationPermissionsModule.ts"],"names":[],"mappings":"4DAAA,OAAS,gBAAT,CAA2B,QAA3B,KAA2C,mBAA3C,CAQA,QAAS,CAAA,uBAAT,CACE,MADF,CAC4C,CAE1C,OAAQ,MAAR,EACE,IAAK,SAAL,CACE,MAAO,CACL,MAAM,CAAE,gBAAgB,CAAC,OADpB,CAEL,OAAO,CAAE,OAFJ,CAGL,WAAW,CAAE,KAHR,CAIL,OAAO,CAAE,IAJJ,CAAP,CAMF,IAAK,QAAL,CACE,MAAO,CACL,MAAM,CAAE,gBAAgB,CAAC,MADpB,CAEL,OAAO,CAAE,OAFJ,CAGL,WAAW,CAAE,KAHR,CAIL,OAAO,CAAE,KAJJ,CAAP,CAMF,QACE,MAAO,CACL,MAAM,CAAE,gBAAgB,CAAC,YADpB,CAEL,OAAO,CAAE,OAFJ,CAGL,WAAW,CAAE,IAHR,CAIL,OAAO,CAAE,KAJJ,CAAP,CAhBJ,CAuBD,CAED,QAAe,CAAA,sBAAf,iPACE,SADF,MACE,SADF,IAKO,QAAQ,CAAC,cALhB,yDAMW,uBAAuB,CAAC,QAAD,CANlC,iBASgC,MAThC,8BASU,YATV,CASU,YATV,+BASyB,EATzB,2BAUM,MAAO,CAAA,YAAY,CAAC,iBAApB,GAA0C,WAVhD,2BAWQ,MAXR,CAWiB,YAAY,CAAC,UAX9B,KAYQ,SAZR,2EAaqB,GAAI,CAAA,OAAJ,CAAY,SAAC,OAAD,CAAU,MAAV,CAAoB,kDAC7C,GAAI,CAAA,QAAQ,CAAG,KAAf,CACA,QAAS,CAAA,WAAT,CAAqB,MAArB,CAAmC,CACjC,GAAI,CAAC,QAAL,CAAe,CACb,QAAQ,CAAG,IAAX,CACA,OAAO,CAAC,MAAD,CAAP,CACD,CACF,CAED,uBAAA,YAAY,CAAC,iBAAb,CAA+B,WAA/B,8DAA6C,IAA7C,CAAkD,WAAlD,uCAAgE,KAAhE,CAAsE,MAAtE,EACD,CAVc,CAbrB,SAaM,MAbN,uDAyBW,uBAAuB,CAAC,MAAD,CAzBlC,eA0Ba,MAAO,CAAA,SAAP,GAAqB,WAArB,cAAoC,SAApC,gCAAoC,WAAW,WAA/C,SAAoC,sBAAwB,KA1BzE,6EA4BwB,SAAS,CAAC,WAAV,CAAsB,KAAtB,CAA4B,CAAE,IAAI,CAAE,eAAR,CAA5B,CA5BxB,UA4BU,KA5BV,+CA6BW,uBAAuB,CAAC,KAAK,CAAC,KAAP,CA7BlC,0CAgCS,uBAAuB,CAAC,QAAD,CAhChC,wEAmCA,cAAe,CACb,WAAW,CAAE,sBAAK,CAAG,CADR,CAEb,eAAe,CAAE,0BAAK,CAAG,CAFZ,CAGP,mBAHO,+BAGY,gLAChB,sBAAsB,CAAC,CAAE,SAAS,CAAE,KAAb,CAAD,CADN,2EAExB,CALY,CAMP,uBANO,kCAOX,OAPW,CAOkC,kLAEtC,sBAAsB,CAAC,CAAE,SAAS,CAAE,IAAb,CAAD,CAFgB,2EAG9C,CAVY,CAAf","sourcesContent":["import { PermissionStatus, Platform } from 'expo-modules-core';\n\nimport {\n  NativeNotificationPermissionsRequest,\n  NotificationPermissionsStatus,\n} from './NotificationPermissions.types';\nimport { NotificationPermissionsModule } from './NotificationPermissionsModule.types';\n\nfunction convertPermissionStatus(\n  status?: NotificationPermission | 'prompt'\n): NotificationPermissionsStatus {\n  switch (status) {\n    case 'granted':\n      return {\n        status: PermissionStatus.GRANTED,\n        expires: 'never',\n        canAskAgain: false,\n        granted: true,\n      };\n    case 'denied':\n      return {\n        status: PermissionStatus.DENIED,\n        expires: 'never',\n        canAskAgain: false,\n        granted: false,\n      };\n    default:\n      return {\n        status: PermissionStatus.UNDETERMINED,\n        expires: 'never',\n        canAskAgain: true,\n        granted: false,\n      };\n  }\n}\n\nasync function resolvePermissionAsync({\n  shouldAsk,\n}: {\n  shouldAsk: boolean;\n}): Promise<NotificationPermissionsStatus> {\n  if (!Platform.isDOMAvailable) {\n    return convertPermissionStatus('denied');\n  }\n\n  const { Notification = {} } = window as any;\n  if (typeof Notification.requestPermission !== 'undefined') {\n    let status = Notification.permission;\n    if (shouldAsk) {\n      status = await new Promise((resolve, reject) => {\n        let resolved = false;\n        function resolveOnce(status: string) {\n          if (!resolved) {\n            resolved = true;\n            resolve(status);\n          }\n        }\n        // Some browsers require a callback argument and some return a Promise\n        Notification.requestPermission(resolveOnce)?.then(resolveOnce)?.catch(reject);\n      });\n    }\n    return convertPermissionStatus(status);\n  } else if (typeof navigator !== 'undefined' && navigator?.permissions?.query) {\n    // TODO(Bacon): Support `push` in the future when it's stable.\n    const query = await navigator.permissions.query({ name: 'notifications' });\n    return convertPermissionStatus(query.state);\n  }\n  // Platforms like iOS Safari don't support Notifications so return denied.\n  return convertPermissionStatus('denied');\n}\n\nexport default {\n  addListener: () => {},\n  removeListeners: () => {},\n  async getPermissionsAsync(): Promise<NotificationPermissionsStatus> {\n    return resolvePermissionAsync({ shouldAsk: false });\n  },\n  async requestPermissionsAsync(\n    request: NativeNotificationPermissionsRequest\n  ): Promise<NotificationPermissionsStatus> {\n    return resolvePermissionAsync({ shouldAsk: true });\n  },\n} as NotificationPermissionsModule;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}