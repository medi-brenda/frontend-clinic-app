{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";import _inherits from\"@babel/runtime/helpers/inherits\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;})),keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){_defineProperty(target,key,source[key]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}return target;}import _regeneratorRuntime from\"@babel/runtime/regenerator\";function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _isNativeReflectConstruct(){if(typeof Reflect===\"undefined\"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy===\"function\")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}import{createPermissionHook,Platform,UnavailabilityError}from'expo-modules-core';import*as React from'react';import findNodeHandle from\"react-native-web/dist/exports/findNodeHandle\";import ExponentCamera from\"./ExponentCamera\";import CameraManager from\"./ExponentCameraManager\";import{ConversionTables,ensureNativeProps}from\"./utils/props\";var EventThrottleMs=500;var _PICTURE_SAVED_CALLBACKS={};var _GLOBAL_PICTURE_ID=1;function ensurePictureOptions(options){var pictureOptions=!options||typeof options!=='object'?{}:options;if(!pictureOptions.quality){pictureOptions.quality=1;}if(pictureOptions.onPictureSaved){var id=_GLOBAL_PICTURE_ID++;_PICTURE_SAVED_CALLBACKS[id]=pictureOptions.onPictureSaved;pictureOptions.id=id;pictureOptions.fastMode=true;}return pictureOptions;}function ensureRecordingOptions(options){var recordingOptions=options||{};if(!recordingOptions||typeof recordingOptions!=='object'){recordingOptions={};}else if(typeof recordingOptions.quality==='string'){recordingOptions.quality=Camera.Constants.VideoQuality[recordingOptions.quality];}return recordingOptions;}function _onPictureSaved(_ref){var nativeEvent=_ref.nativeEvent;var id=nativeEvent.id,data=nativeEvent.data;var callback=_PICTURE_SAVED_CALLBACKS[id];if(callback){callback(data);delete _PICTURE_SAVED_CALLBACKS[id];}}var Camera=function(_React$Component){_inherits(Camera,_React$Component);var _super=_createSuper(Camera);function Camera(){var _this;_classCallCheck(this,Camera);for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_super.call.apply(_super,[this].concat(args));_this._lastEvents={};_this._lastEventsTimes={};_this._onCameraReady=function(){if(_this.props.onCameraReady){_this.props.onCameraReady();}};_this._onMountError=function(_ref2){var nativeEvent=_ref2.nativeEvent;if(_this.props.onMountError){_this.props.onMountError(nativeEvent);}};_this._onObjectDetected=function(callback){return function(_ref3){var nativeEvent=_ref3.nativeEvent;var type=nativeEvent.type;if(_this._lastEvents[type]&&_this._lastEventsTimes[type]&&JSON.stringify(nativeEvent)===_this._lastEvents[type]&&new Date().getTime()-_this._lastEventsTimes[type].getTime()<EventThrottleMs){return;}if(callback){callback(nativeEvent);_this._lastEventsTimes[type]=new Date();_this._lastEvents[type]=JSON.stringify(nativeEvent);}};};_this._setReference=function(ref){if(ref){_this._cameraRef=ref;if(Platform.OS==='web'){_this._cameraHandle=ref;}else{_this._cameraHandle=findNodeHandle(ref);}}else{_this._cameraRef=null;_this._cameraHandle=null;}};return _this;}_createClass(Camera,[{key:\"takePictureAsync\",value:function takePictureAsync(options){var pictureOptions;return _regeneratorRuntime.async(function takePictureAsync$(_context){while(1){switch(_context.prev=_context.next){case 0:pictureOptions=ensurePictureOptions(options);_context.next=3;return _regeneratorRuntime.awrap(CameraManager.takePicture(pictureOptions,this._cameraHandle));case 3:return _context.abrupt(\"return\",_context.sent);case 4:case\"end\":return _context.stop();}}},null,this,null,Promise);}},{key:\"getSupportedRatiosAsync\",value:function getSupportedRatiosAsync(){return _regeneratorRuntime.async(function getSupportedRatiosAsync$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:if(CameraManager.getSupportedRatios){_context2.next=2;break;}throw new UnavailabilityError('Camera','getSupportedRatiosAsync');case 2:_context2.next=4;return _regeneratorRuntime.awrap(CameraManager.getSupportedRatios(this._cameraHandle));case 4:return _context2.abrupt(\"return\",_context2.sent);case 5:case\"end\":return _context2.stop();}}},null,this,null,Promise);}},{key:\"getAvailablePictureSizesAsync\",value:function getAvailablePictureSizesAsync(ratio){return _regeneratorRuntime.async(function getAvailablePictureSizesAsync$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:if(CameraManager.getAvailablePictureSizes){_context3.next=2;break;}throw new UnavailabilityError('Camera','getAvailablePictureSizesAsync');case 2:_context3.next=4;return _regeneratorRuntime.awrap(CameraManager.getAvailablePictureSizes(ratio,this._cameraHandle));case 4:return _context3.abrupt(\"return\",_context3.sent);case 5:case\"end\":return _context3.stop();}}},null,this,null,Promise);}},{key:\"recordAsync\",value:function recordAsync(options){var recordingOptions;return _regeneratorRuntime.async(function recordAsync$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:if(CameraManager.record){_context4.next=2;break;}throw new UnavailabilityError('Camera','recordAsync');case 2:recordingOptions=ensureRecordingOptions(options);_context4.next=5;return _regeneratorRuntime.awrap(CameraManager.record(recordingOptions,this._cameraHandle));case 5:return _context4.abrupt(\"return\",_context4.sent);case 6:case\"end\":return _context4.stop();}}},null,this,null,Promise);}},{key:\"stopRecording\",value:function stopRecording(){if(!CameraManager.stopRecording){throw new UnavailabilityError('Camera','stopRecording');}CameraManager.stopRecording(this._cameraHandle);}},{key:\"pausePreview\",value:function pausePreview(){if(!CameraManager.pausePreview){throw new UnavailabilityError('Camera','pausePreview');}CameraManager.pausePreview(this._cameraHandle);}},{key:\"resumePreview\",value:function resumePreview(){if(!CameraManager.resumePreview){throw new UnavailabilityError('Camera','resumePreview');}CameraManager.resumePreview(this._cameraHandle);}},{key:\"render\",value:function render(){var nativeProps=ensureNativeProps(this.props);var onBarCodeScanned=this.props.onBarCodeScanned?this._onObjectDetected(this.props.onBarCodeScanned):undefined;var onFacesDetected=this._onObjectDetected(this.props.onFacesDetected);return React.createElement(ExponentCamera,_objectSpread(_objectSpread({},nativeProps),{},{ref:this._setReference,onCameraReady:this._onCameraReady,onMountError:this._onMountError,onBarCodeScanned:onBarCodeScanned,onFacesDetected:onFacesDetected,onPictureSaved:_onPictureSaved}));}}],[{key:\"isAvailableAsync\",value:function isAvailableAsync(){return _regeneratorRuntime.async(function isAvailableAsync$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:if(CameraManager.isAvailableAsync){_context5.next=2;break;}throw new UnavailabilityError('expo-camera','isAvailableAsync');case 2:_context5.next=4;return _regeneratorRuntime.awrap(CameraManager.isAvailableAsync());case 4:return _context5.abrupt(\"return\",_context5.sent);case 5:case\"end\":return _context5.stop();}}},null,null,null,Promise);}},{key:\"getAvailableCameraTypesAsync\",value:function getAvailableCameraTypesAsync(){return _regeneratorRuntime.async(function getAvailableCameraTypesAsync$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:if(CameraManager.getAvailableCameraTypesAsync){_context6.next=2;break;}throw new UnavailabilityError('expo-camera','getAvailableCameraTypesAsync');case 2:_context6.next=4;return _regeneratorRuntime.awrap(CameraManager.getAvailableCameraTypesAsync());case 4:return _context6.abrupt(\"return\",_context6.sent);case 5:case\"end\":return _context6.stop();}}},null,null,null,Promise);}},{key:\"getAvailableVideoCodecsAsync\",value:function getAvailableVideoCodecsAsync(){return _regeneratorRuntime.async(function getAvailableVideoCodecsAsync$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:if(CameraManager.getAvailableVideoCodecsAsync){_context7.next=2;break;}throw new UnavailabilityError('Camera','getAvailableVideoCodecsAsync');case 2:_context7.next=4;return _regeneratorRuntime.awrap(CameraManager.getAvailableVideoCodecsAsync());case 4:return _context7.abrupt(\"return\",_context7.sent);case 5:case\"end\":return _context7.stop();}}},null,null,null,Promise);}},{key:\"getPermissionsAsync\",value:function getPermissionsAsync(){return _regeneratorRuntime.async(function getPermissionsAsync$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:console.warn(\"\\\"getPermissionsAsync()\\\" is now deprecated. Please use \\\"getCameraPermissionsAsync()\\\" or \\\"getMicrophonePermissionsAsync()\\\" instead.\");return _context8.abrupt(\"return\",CameraManager.getPermissionsAsync());case 2:case\"end\":return _context8.stop();}}},null,null,null,Promise);}},{key:\"requestPermissionsAsync\",value:function requestPermissionsAsync(){return _regeneratorRuntime.async(function requestPermissionsAsync$(_context9){while(1){switch(_context9.prev=_context9.next){case 0:console.warn(\"\\\"requestPermissionsAsync()\\\" is now deprecated. Please use \\\"requestCameraPermissionsAsync()\\\" or \\\"requestMicrophonePermissionsAsync()\\\" instead.\");return _context9.abrupt(\"return\",CameraManager.requestPermissionsAsync());case 2:case\"end\":return _context9.stop();}}},null,null,null,Promise);}},{key:\"getCameraPermissionsAsync\",value:function getCameraPermissionsAsync(){return _regeneratorRuntime.async(function getCameraPermissionsAsync$(_context10){while(1){switch(_context10.prev=_context10.next){case 0:return _context10.abrupt(\"return\",CameraManager.getCameraPermissionsAsync());case 1:case\"end\":return _context10.stop();}}},null,null,null,Promise);}},{key:\"requestCameraPermissionsAsync\",value:function requestCameraPermissionsAsync(){return _regeneratorRuntime.async(function requestCameraPermissionsAsync$(_context11){while(1){switch(_context11.prev=_context11.next){case 0:return _context11.abrupt(\"return\",CameraManager.requestCameraPermissionsAsync());case 1:case\"end\":return _context11.stop();}}},null,null,null,Promise);}},{key:\"getMicrophonePermissionsAsync\",value:function getMicrophonePermissionsAsync(){return _regeneratorRuntime.async(function getMicrophonePermissionsAsync$(_context12){while(1){switch(_context12.prev=_context12.next){case 0:return _context12.abrupt(\"return\",CameraManager.getMicrophonePermissionsAsync());case 1:case\"end\":return _context12.stop();}}},null,null,null,Promise);}},{key:\"requestMicrophonePermissionsAsync\",value:function requestMicrophonePermissionsAsync(){return _regeneratorRuntime.async(function requestMicrophonePermissionsAsync$(_context13){while(1){switch(_context13.prev=_context13.next){case 0:return _context13.abrupt(\"return\",CameraManager.requestMicrophonePermissionsAsync());case 1:case\"end\":return _context13.stop();}}},null,null,null,Promise);}}]);return Camera;}(React.Component);Camera.Constants={Type:CameraManager.Type,FlashMode:CameraManager.FlashMode,AutoFocus:CameraManager.AutoFocus,WhiteBalance:CameraManager.WhiteBalance,VideoQuality:CameraManager.VideoQuality,VideoStabilization:CameraManager.VideoStabilization||{},VideoCodec:CameraManager.VideoCodec};Camera.ConversionTables=ConversionTables;Camera.defaultProps={zoom:0,ratio:'4:3',focusDepth:0,faceDetectorSettings:{},type:CameraManager.Type.back,autoFocus:CameraManager.AutoFocus.on,flashMode:CameraManager.FlashMode.off,whiteBalance:CameraManager.WhiteBalance.auto};Camera.useCameraPermissions=createPermissionHook({getMethod:Camera.getCameraPermissionsAsync,requestMethod:Camera.requestCameraPermissionsAsync});Camera.useMicrophonePermissions=createPermissionHook({getMethod:Camera.getMicrophonePermissionsAsync,requestMethod:Camera.requestMicrophonePermissionsAsync});export{Camera as default};var Constants=Camera.Constants,getPermissionsAsync=Camera.getPermissionsAsync,requestPermissionsAsync=Camera.requestPermissionsAsync,getCameraPermissionsAsync=Camera.getCameraPermissionsAsync,requestCameraPermissionsAsync=Camera.requestCameraPermissionsAsync,getMicrophonePermissionsAsync=Camera.getMicrophonePermissionsAsync,requestMicrophonePermissionsAsync=Camera.requestMicrophonePermissionsAsync;export{Constants,getPermissionsAsync,requestPermissionsAsync,getCameraPermissionsAsync,requestCameraPermissionsAsync,getMicrophonePermissionsAsync,requestMicrophonePermissionsAsync};","map":{"version":3,"sources":["../src/Camera.tsx"],"names":[],"mappings":"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","sourcesContent":["import { createPermissionHook, Platform, UnavailabilityError } from 'expo-modules-core';\nimport * as React from 'react';\nimport { findNodeHandle } from 'react-native';\n\nimport {\n  CameraCapturedPicture,\n  CameraPictureOptions,\n  CameraProps,\n  CameraRecordingOptions,\n  CameraType,\n  ConstantsType,\n  PermissionResponse,\n  VideoCodec,\n} from './Camera.types';\nimport ExponentCamera from './ExponentCamera';\nimport CameraManager from './ExponentCameraManager';\nimport { ConversionTables, ensureNativeProps } from './utils/props';\n\nconst EventThrottleMs = 500;\n\nconst _PICTURE_SAVED_CALLBACKS = {};\n\nlet _GLOBAL_PICTURE_ID = 1;\n\nfunction ensurePictureOptions(options?: CameraPictureOptions): CameraPictureOptions {\n  const pictureOptions: CameraPictureOptions =\n    !options || typeof options !== 'object' ? {} : options;\n\n  if (!pictureOptions.quality) {\n    pictureOptions.quality = 1;\n  }\n  if (pictureOptions.onPictureSaved) {\n    const id = _GLOBAL_PICTURE_ID++;\n    _PICTURE_SAVED_CALLBACKS[id] = pictureOptions.onPictureSaved;\n    pictureOptions.id = id;\n    pictureOptions.fastMode = true;\n  }\n  return pictureOptions;\n}\n\nfunction ensureRecordingOptions(options?: CameraRecordingOptions): CameraRecordingOptions {\n  let recordingOptions = options || {};\n\n  if (!recordingOptions || typeof recordingOptions !== 'object') {\n    recordingOptions = {};\n  } else if (typeof recordingOptions.quality === 'string') {\n    recordingOptions.quality = Camera.Constants.VideoQuality[recordingOptions.quality];\n  }\n\n  return recordingOptions;\n}\n\nfunction _onPictureSaved({\n  nativeEvent,\n}: {\n  nativeEvent: { data: CameraCapturedPicture; id: number };\n}) {\n  const { id, data } = nativeEvent;\n  const callback = _PICTURE_SAVED_CALLBACKS[id];\n  if (callback) {\n    callback(data);\n    delete _PICTURE_SAVED_CALLBACKS[id];\n  }\n}\n\nexport default class Camera extends React.Component<CameraProps> {\n  /**\n   * Check whether the current device has a camera. This is useful for web and simulators cases.\n   * This isn't influenced by the Permissions API (all platforms), or HTTP usage (in the browser).\n   * You will still need to check if the native permission has been accepted.\n   * @platform web\n   */\n  static async isAvailableAsync(): Promise<boolean> {\n    if (!CameraManager.isAvailableAsync) {\n      throw new UnavailabilityError('expo-camera', 'isAvailableAsync');\n    }\n\n    return await CameraManager.isAvailableAsync();\n  }\n\n  /**\n   * Returns a list of camera types `['front', 'back']`. This is useful for desktop browsers which only have front-facing cameras.\n   * @platform web\n   */\n  static async getAvailableCameraTypesAsync(): Promise<CameraType[]> {\n    if (!CameraManager.getAvailableCameraTypesAsync) {\n      throw new UnavailabilityError('expo-camera', 'getAvailableCameraTypesAsync');\n    }\n\n    return await CameraManager.getAvailableCameraTypesAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Queries the device for the available video codecs that can be used in video recording.\n   * @return A promise that resolves to a list of strings that represents available codecs.\n   * @platform ios\n   */\n  static async getAvailableVideoCodecsAsync(): Promise<VideoCodec[]> {\n    if (!CameraManager.getAvailableVideoCodecsAsync) {\n      throw new UnavailabilityError('Camera', 'getAvailableVideoCodecsAsync');\n    }\n\n    return await CameraManager.getAvailableVideoCodecsAsync();\n  }\n\n  static Constants: ConstantsType = {\n    Type: CameraManager.Type,\n    FlashMode: CameraManager.FlashMode,\n    AutoFocus: CameraManager.AutoFocus,\n    WhiteBalance: CameraManager.WhiteBalance,\n    VideoQuality: CameraManager.VideoQuality,\n    VideoStabilization: CameraManager.VideoStabilization || {},\n    VideoCodec: CameraManager.VideoCodec,\n  };\n\n  // Values under keys from this object will be transformed to native options\n  static ConversionTables = ConversionTables;\n\n  static defaultProps: CameraProps = {\n    zoom: 0,\n    ratio: '4:3',\n    focusDepth: 0,\n    faceDetectorSettings: {},\n    type: CameraManager.Type.back,\n    autoFocus: CameraManager.AutoFocus.on,\n    flashMode: CameraManager.FlashMode.off,\n    whiteBalance: CameraManager.WhiteBalance.auto,\n  };\n\n  // @needsAudit\n  /**\n   * @deprecated Deprecated. Use `getCameraPermissionsAsync` or `getMicrophonePermissionsAsync` instead.\n   * Checks user's permissions for accessing camera.\n   */\n  static async getPermissionsAsync(): Promise<PermissionResponse> {\n    console.warn(\n      `\"getPermissionsAsync()\" is now deprecated. Please use \"getCameraPermissionsAsync()\" or \"getMicrophonePermissionsAsync()\" instead.`\n    );\n    return CameraManager.getPermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Asks the user to grant permissions for accessing camera.\n   * On iOS this will require apps to specify both `NSCameraUsageDescription` and `NSMicrophoneUsageDescription` entries in the **Info.plist**.\n   * @return A promise that resolves to an object of type [PermissionResponse](#permissionresponse).\n   * @deprecated Use `requestCameraPermissionsAsync` or `requestMicrophonePermissionsAsync` instead.\n   */\n  static async requestPermissionsAsync(): Promise<PermissionResponse> {\n    console.warn(\n      `\"requestPermissionsAsync()\" is now deprecated. Please use \"requestCameraPermissionsAsync()\" or \"requestMicrophonePermissionsAsync()\" instead.`\n    );\n    return CameraManager.requestPermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Checks user's permissions for accessing camera.\n   * @return A promise that resolves to an object of type [PermissionResponse](#permissionresponse).\n   */\n  static async getCameraPermissionsAsync(): Promise<PermissionResponse> {\n    return CameraManager.getCameraPermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Asks the user to grant permissions for accessing camera.\n   * On iOS this will require apps to specify an `NSCameraUsageDescription` entry in the **Info.plist**.\n   * @return A promise that resolves to an object of type [PermissionResponse](#permissionresponse).\n   */\n  static async requestCameraPermissionsAsync(): Promise<PermissionResponse> {\n    return CameraManager.requestCameraPermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Check or request permissions to access the camera.\n   * This uses both `requestCameraPermissionsAsync` and `getCameraPermissionsAsync` to interact with the permissions.\n   *\n   * @example\n   * ```ts\n   * const [status, requestPermission] = Camera.useCameraPermissions();\n   * ```\n   */\n  static useCameraPermissions = createPermissionHook({\n    getMethod: Camera.getCameraPermissionsAsync,\n    requestMethod: Camera.requestCameraPermissionsAsync,\n  });\n\n  // @needsAudit\n  /**\n   * Checks user's permissions for accessing microphone.\n   * @return A promise that resolves to an object of type [PermissionResponse](#permissionresponse).\n   */\n  static async getMicrophonePermissionsAsync(): Promise<PermissionResponse> {\n    return CameraManager.getMicrophonePermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Asks the user to grant permissions for accessing the microphone.\n   * On iOS this will require apps to specify an `NSMicrophoneUsageDescription` entry in the **Info.plist**.\n   * @return A promise that resolves to an object of type [PermissionResponse](#permissionresponse).\n   */\n  static async requestMicrophonePermissionsAsync(): Promise<PermissionResponse> {\n    return CameraManager.requestMicrophonePermissionsAsync();\n  }\n\n  // @needsAudit\n  /**\n   * Check or request permissions to access the microphone.\n   * This uses both `requestMicrophonePermissionsAsync` and `getMicrophonePermissionsAsync` to interact with the permissions.\n   *\n   * @example\n   * ```ts\n   * const [status, requestPermission] = Camera.useMicrophonePermissions();\n   * ```\n   */\n  static useMicrophonePermissions = createPermissionHook({\n    getMethod: Camera.getMicrophonePermissionsAsync,\n    requestMethod: Camera.requestMicrophonePermissionsAsync,\n  });\n\n  _cameraHandle?: number | null;\n  _cameraRef?: React.Component | null;\n  _lastEvents: { [eventName: string]: string } = {};\n  _lastEventsTimes: { [eventName: string]: Date } = {};\n\n  // @needsAudit\n  /**\n   * Takes a picture and saves it to app's cache directory. Photos are rotated to match device's orientation\n   * (if `options.skipProcessing` flag is not enabled) and scaled to match the preview. Anyway on Android it is essential\n   * to set ratio prop to get a picture with correct dimensions.\n   * > **Note**: Make sure to wait for the [`onCameraReady`](#oncameraready) callback before calling this method.\n   * @param options An object in form of `CameraPictureOptions` type.\n   * @return Returns a Promise that resolves to `CameraCapturedPicture` object, where `uri` is a URI to the local image file on iOS,\n   * Android, and a base64 string on web (usable as the source for an `Image` element). The `width` and `height` properties specify\n   * the dimensions of the image. `base64` is included if the `base64` option was truthy, and is a string containing the JPEG data\n   * of the image in Base64--prepend that with `'data:image/jpg;base64,'` to get a data URI, which you can use as the source\n   * for an `Image` element for example. `exif` is included if the `exif` option was truthy, and is an object containing EXIF\n   * data for the image--the names of its properties are EXIF tags and their values are the values for those tags.\n   *\n   * > On native platforms, the local image URI is temporary. Use [`FileSystem.copyAsync`](filesystem.md#filesystemcopyasyncoptions)\n   * > to make a permanent copy of the image.\n   *\n   * > On web, the `uri` is a base64 representation of the image because file system URLs are not supported in the browser.\n   * > The `exif` data returned on web is a partial representation of the [`MediaTrackSettings`](https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings),\n   * > if available.\n   */\n  async takePictureAsync(options?: CameraPictureOptions): Promise<CameraCapturedPicture> {\n    const pictureOptions = ensurePictureOptions(options);\n\n    return await CameraManager.takePicture(pictureOptions, this._cameraHandle);\n  }\n\n  /**\n   * Get aspect ratios that are supported by the device and can be passed via `ratio` prop.\n   * @return Returns a Promise that resolves to an array of strings representing ratios, eg. `['4:3', '1:1']`.\n   * @platform android\n   */\n  async getSupportedRatiosAsync(): Promise<string[]> {\n    if (!CameraManager.getSupportedRatios) {\n      throw new UnavailabilityError('Camera', 'getSupportedRatiosAsync');\n    }\n\n    return await CameraManager.getSupportedRatios(this._cameraHandle);\n  }\n\n  /**\n   * Get picture sizes that are supported by the device for given `ratio`.\n   * @param ratio A string representing aspect ratio of sizes to be returned.\n   * @return Returns a Promise that resolves to an array of strings representing picture sizes that can be passed to `pictureSize` prop.\n   * The list varies across Android devices but is the same for every iOS.\n   */\n  async getAvailablePictureSizesAsync(ratio?: string): Promise<string[]> {\n    if (!CameraManager.getAvailablePictureSizes) {\n      throw new UnavailabilityError('Camera', 'getAvailablePictureSizesAsync');\n    }\n    return await CameraManager.getAvailablePictureSizes(ratio, this._cameraHandle);\n  }\n\n  /**\n   * Starts recording a video that will be saved to cache directory. Videos are rotated to match device's orientation.\n   * Flipping camera during a recording results in stopping it.\n   * @param options A map of `CameraRecordingOptions` type.\n   * @return Returns a Promise that resolves to an object containing video file `uri` property and a `codec` property on iOS.\n   * The Promise is returned if `stopRecording` was invoked, one of `maxDuration` and `maxFileSize` is reached or camera preview is stopped.\n   * @platform android\n   * @platform ios\n   */\n  async recordAsync(options?: CameraRecordingOptions): Promise<{ uri: string }> {\n    if (!CameraManager.record) {\n      throw new UnavailabilityError('Camera', 'recordAsync');\n    }\n\n    const recordingOptions = ensureRecordingOptions(options);\n    return await CameraManager.record(recordingOptions, this._cameraHandle);\n  }\n\n  /**\n   * Stops recording if any is in progress.\n   */\n  stopRecording() {\n    if (!CameraManager.stopRecording) {\n      throw new UnavailabilityError('Camera', 'stopRecording');\n    }\n\n    CameraManager.stopRecording(this._cameraHandle);\n  }\n\n  /**\n   * Pauses the camera preview. It is not recommended to use `takePictureAsync` when preview is paused.\n   */\n  pausePreview() {\n    if (!CameraManager.pausePreview) {\n      throw new UnavailabilityError('Camera', 'pausePreview');\n    }\n\n    CameraManager.pausePreview(this._cameraHandle);\n  }\n\n  /**\n   * Resumes the camera preview.\n   */\n  resumePreview() {\n    if (!CameraManager.resumePreview) {\n      throw new UnavailabilityError('Camera', 'resumePreview');\n    }\n\n    CameraManager.resumePreview(this._cameraHandle);\n  }\n\n  _onCameraReady = () => {\n    if (this.props.onCameraReady) {\n      this.props.onCameraReady();\n    }\n  };\n\n  _onMountError = ({ nativeEvent }: { nativeEvent: { message: string } }) => {\n    if (this.props.onMountError) {\n      this.props.onMountError(nativeEvent);\n    }\n  };\n\n  _onObjectDetected =\n    (callback?: Function) =>\n    ({ nativeEvent }: { nativeEvent: any }) => {\n      const { type } = nativeEvent;\n      if (\n        this._lastEvents[type] &&\n        this._lastEventsTimes[type] &&\n        JSON.stringify(nativeEvent) === this._lastEvents[type] &&\n        new Date().getTime() - this._lastEventsTimes[type].getTime() < EventThrottleMs\n      ) {\n        return;\n      }\n\n      if (callback) {\n        callback(nativeEvent);\n        this._lastEventsTimes[type] = new Date();\n        this._lastEvents[type] = JSON.stringify(nativeEvent);\n      }\n    };\n\n  _setReference = (ref?: React.Component) => {\n    if (ref) {\n      this._cameraRef = ref;\n      // TODO(Bacon): Unify these - perhaps with hooks?\n      if (Platform.OS === 'web') {\n        this._cameraHandle = ref as any;\n      } else {\n        this._cameraHandle = findNodeHandle(ref);\n      }\n    } else {\n      this._cameraRef = null;\n      this._cameraHandle = null;\n    }\n  };\n\n  render() {\n    const nativeProps = ensureNativeProps(this.props);\n\n    const onBarCodeScanned = this.props.onBarCodeScanned\n      ? this._onObjectDetected(this.props.onBarCodeScanned)\n      : undefined;\n    const onFacesDetected = this._onObjectDetected(this.props.onFacesDetected);\n\n    return (\n      <ExponentCamera\n        {...nativeProps}\n        ref={this._setReference}\n        onCameraReady={this._onCameraReady}\n        onMountError={this._onMountError}\n        onBarCodeScanned={onBarCodeScanned}\n        onFacesDetected={onFacesDetected}\n        onPictureSaved={_onPictureSaved}\n      />\n    );\n  }\n}\n\nexport const {\n  Constants,\n  getPermissionsAsync,\n  requestPermissionsAsync,\n  getCameraPermissionsAsync,\n  requestCameraPermissionsAsync,\n  getMicrophonePermissionsAsync,\n  requestMicrophonePermissionsAsync,\n} = Camera;\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}