{"ast":null,"code":"import _regeneratorRuntime from\"@babel/runtime/regenerator\";import'abort-controller/polyfill';import{UnavailabilityError}from'expo-modules-core';import ServerRegistrationModule from\"./ServerRegistrationModule\";import{addPushTokenListener}from\"./TokenEmitter\";import getDevicePushTokenAsync from\"./getDevicePushTokenAsync\";import{updateDevicePushTokenAsync as updateDevicePushTokenAsyncWithSignal}from\"./utils/updateDevicePushTokenAsync\";var lastAbortController=null;function updatePushTokenAsync(token){var _lastAbortController;return _regeneratorRuntime.async(function updatePushTokenAsync$(_context){while(1){switch(_context.prev=_context.next){case 0:(_lastAbortController=lastAbortController)==null?void 0:_lastAbortController.abort();lastAbortController=new AbortController();_context.next=4;return _regeneratorRuntime.awrap(updateDevicePushTokenAsyncWithSignal(lastAbortController.signal,token));case 4:return _context.abrupt(\"return\",_context.sent);case 5:case\"end\":return _context.stop();}}},null,null,null,Promise);}export function setAutoServerRegistrationEnabledAsync(enabled){var _lastAbortController2;return _regeneratorRuntime.async(function setAutoServerRegistrationEnabledAsync$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:(_lastAbortController2=lastAbortController)==null?void 0:_lastAbortController2.abort();if(ServerRegistrationModule.setRegistrationInfoAsync){_context2.next=3;break;}throw new UnavailabilityError('ServerRegistrationModule','setRegistrationInfoAsync');case 3:_context2.next=5;return _regeneratorRuntime.awrap(ServerRegistrationModule.setRegistrationInfoAsync(enabled?JSON.stringify({isEnabled:enabled}):null));case 5:case\"end\":return _context2.stop();}}},null,null,null,Promise);}export function __handlePersistedRegistrationInfoAsync(registrationInfo){var _registration;var registration,latestDevicePushToken;return _regeneratorRuntime.async(function __handlePersistedRegistrationInfoAsync$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:if(registrationInfo){_context3.next=2;break;}return _context3.abrupt(\"return\");case 2:registration=null;try{registration=JSON.parse(registrationInfo);}catch(e){console.warn('[expo-notifications] Error encountered while fetching registration information for auto token updates.',e);}if((_registration=registration)!=null&&_registration.isEnabled){_context3.next=6;break;}return _context3.abrupt(\"return\");case 6:_context3.prev=6;_context3.next=9;return _regeneratorRuntime.awrap(getDevicePushTokenAsync());case 9:latestDevicePushToken=_context3.sent;_context3.next=12;return _regeneratorRuntime.awrap(updatePushTokenAsync(latestDevicePushToken));case 12:_context3.next=17;break;case 14:_context3.prev=14;_context3.t0=_context3[\"catch\"](6);console.warn('[expo-notifications] Error encountered while updating server registration with latest device push token.',_context3.t0);case 17:case\"end\":return _context3.stop();}}},null,null,[[6,14]],Promise);}if(ServerRegistrationModule.getRegistrationInfoAsync){addPushTokenListener(function _callee(token){var registrationInfo,registration;return _regeneratorRuntime.async(function _callee$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:_context4.prev=0;_context4.next=3;return _regeneratorRuntime.awrap(ServerRegistrationModule.getRegistrationInfoAsync());case 3:registrationInfo=_context4.sent;if(registrationInfo){_context4.next=6;break;}return _context4.abrupt(\"return\");case 6:registration=JSON.parse(registrationInfo);if(!(registration!=null&&registration.isEnabled)){_context4.next=10;break;}_context4.next=10;return _regeneratorRuntime.awrap(updatePushTokenAsync(token));case 10:_context4.next=15;break;case 12:_context4.prev=12;_context4.t0=_context4[\"catch\"](0);console.warn('[expo-notifications] Error encountered while updating server registration with latest device push token.',_context4.t0);case 15:case\"end\":return _context4.stop();}}},null,null,[[0,12]],Promise);});ServerRegistrationModule.getRegistrationInfoAsync().then(__handlePersistedRegistrationInfoAsync);}else{console.warn(\"[expo-notifications] Error encountered while fetching auto-registration state, new tokens will not be automatically registered on server.\",new UnavailabilityError('ServerRegistrationModule','getRegistrationInfoAsync'));}","map":{"version":3,"sources":["../src/DevicePushTokenAutoRegistration.fx.ts"],"names":[],"mappings":"4DAAA,MAAO,2BAAP,CACA,OAAS,mBAAT,KAAoC,mBAApC,CAEA,MAAO,CAAA,wBAAP,kCACA,OAAS,oBAAT,sBAEA,MAAO,CAAA,uBAAP,iCACA,OAAS,0BAA0B,GAAI,CAAA,oCAAvC,0CAEA,GAAI,CAAA,mBAAmB,CAA2B,IAAlD,CACA,QAAe,CAAA,oBAAf,CAAoC,KAApC,yJAEE,sBAAA,mBAAmB,OAAnB,6BAAqB,KAArB,GACA,mBAAmB,CAAG,GAAI,CAAA,eAAJ,EAAtB,CAHF,iDAIe,oCAAoC,CAAC,mBAAmB,CAAC,MAArB,CAA6B,KAA7B,CAJnD,6HAmBA,MAAO,SAAe,CAAA,qCAAf,CAAqD,OAArD,8KAGL,uBAAA,mBAAmB,OAAnB,8BAAqB,KAArB,GAHK,GAKA,wBAAwB,CAAC,wBALzB,+BAMG,IAAI,CAAA,mBAAJ,CAAwB,0BAAxB,CAAoD,0BAApD,CANH,0DASC,wBAAwB,CAAC,wBAAzB,CACJ,OAAO,CAAG,IAAI,CAAC,SAAL,CAAe,CAAE,SAAS,CAAE,OAAb,CAAf,CAAH,CAA4C,IAD/C,CATD,wEAiBP,MAAO,SAAe,CAAA,sCAAf,CACL,gBADK,iNAGA,gBAHA,mEAQD,YARC,CAQkD,IARlD,CASL,GAAI,CACF,YAAY,CAAG,IAAI,CAAC,KAAL,CAAW,gBAAX,CAAf,CACD,CAAC,MAAO,CAAP,CAAU,CACV,OAAO,CAAC,IAAR,CACE,wGADF,CAEE,CAFF,EAID,CAhBI,kBAkBA,YAlBA,SAkBA,cAAc,SAlBd,sIA0BiC,uBAAuB,EA1BxD,SA0BG,qBA1BH,mEA2BG,oBAAoB,CAAC,qBAAD,CA3BvB,+FA6BH,OAAO,CAAC,IAAR,CACE,0GADF,eA7BG,2EAoCP,GAAI,wBAAwB,CAAC,wBAA7B,CAAuD,CAGrD,oBAAoB,CAAC,iBAAO,KAAP,2NAKc,wBAAwB,CAAC,wBAAzB,EALd,SAKX,gBALW,mBAOZ,gBAPY,mEAYX,YAZW,CAYwC,IAAI,CAAC,KAAL,CAAW,gBAAX,CAZxC,MAab,YAba,QAab,YAAY,CAAE,SAbD,+EAgBT,oBAAoB,CAAC,KAAD,CAhBX,+FAmBjB,OAAO,CAAC,IAAR,CACE,0GADF,eAnBiB,2EAAD,CAApB,CA6BA,wBAAwB,CAAC,wBAAzB,GAAoD,IAApD,CAAyD,sCAAzD,EACD,CAjCD,IAiCO,CACL,OAAO,CAAC,IAAR,6IAEE,GAAI,CAAA,mBAAJ,CAAwB,0BAAxB,CAAoD,0BAApD,CAFF,EAID","sourcesContent":["import 'abort-controller/polyfill';\nimport { UnavailabilityError } from 'expo-modules-core';\n\nimport ServerRegistrationModule from './ServerRegistrationModule';\nimport { addPushTokenListener } from './TokenEmitter';\nimport { DevicePushToken } from './Tokens.types';\nimport getDevicePushTokenAsync from './getDevicePushTokenAsync';\nimport { updateDevicePushTokenAsync as updateDevicePushTokenAsyncWithSignal } from './utils/updateDevicePushTokenAsync';\n\nlet lastAbortController: AbortController | null = null;\nasync function updatePushTokenAsync(token: DevicePushToken) {\n  // Abort current update process\n  lastAbortController?.abort();\n  lastAbortController = new AbortController();\n  return await updateDevicePushTokenAsyncWithSignal(lastAbortController.signal, token);\n}\n\n/**\n * Encapsulates device server registration data\n */\nexport type DevicePushTokenRegistration = {\n  isEnabled: boolean;\n};\n\n/**\n * Sets the registration information so that the device push token gets pushed\n * to the given registration endpoint\n * @param registration Registration endpoint to inform of new tokens\n */\nexport async function setAutoServerRegistrationEnabledAsync(enabled: boolean) {\n  // We are overwriting registration, so we shouldn't let\n  // any pending request complete.\n  lastAbortController?.abort();\n\n  if (!ServerRegistrationModule.setRegistrationInfoAsync) {\n    throw new UnavailabilityError('ServerRegistrationModule', 'setRegistrationInfoAsync');\n  }\n\n  await ServerRegistrationModule.setRegistrationInfoAsync(\n    enabled ? JSON.stringify({ isEnabled: enabled }) : null\n  );\n}\n\n/**\n * This function is exported only for testing purposes.\n */\nexport async function __handlePersistedRegistrationInfoAsync(\n  registrationInfo: string | null | undefined\n) {\n  if (!registrationInfo) {\n    // No registration info, nothing to do\n    return;\n  }\n\n  let registration: DevicePushTokenRegistration | null = null;\n  try {\n    registration = JSON.parse(registrationInfo);\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Error encountered while fetching registration information for auto token updates.',\n      e\n    );\n  }\n\n  if (!registration?.isEnabled) {\n    // Registration is invalid or not enabled, nothing more to do\n    return;\n  }\n\n  try {\n    // Since the registration is enabled, fetching a \"new\" device token\n    // shouldn't be a problem.\n    const latestDevicePushToken = await getDevicePushTokenAsync();\n    await updatePushTokenAsync(latestDevicePushToken);\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Error encountered while updating server registration with latest device push token.',\n      e\n    );\n  }\n}\n\nif (ServerRegistrationModule.getRegistrationInfoAsync) {\n  // A global scope (to get all the updates) device push token\n  // subscription, never cleared.\n  addPushTokenListener(async (token) => {\n    try {\n      // Before updating the push token on server we always check if we should\n      // Since modules can't change their method availability while running, we\n      // can assert it's defined.\n      const registrationInfo = await ServerRegistrationModule.getRegistrationInfoAsync!();\n\n      if (!registrationInfo) {\n        // Registration is not enabled\n        return;\n      }\n\n      const registration: DevicePushTokenRegistration | null = JSON.parse(registrationInfo);\n      if (registration?.isEnabled) {\n        // Dispatch an abortable task to update\n        // registration with new token.\n        await updatePushTokenAsync(token);\n      }\n    } catch (e) {\n      console.warn(\n        '[expo-notifications] Error encountered while updating server registration with latest device push token.',\n        e\n      );\n    }\n  });\n\n  // Verify if persisted registration\n  // has successfully uploaded last known\n  // device push token. If not, retry.\n  ServerRegistrationModule.getRegistrationInfoAsync().then(__handlePersistedRegistrationInfoAsync);\n} else {\n  console.warn(\n    `[expo-notifications] Error encountered while fetching auto-registration state, new tokens will not be automatically registered on server.`,\n    new UnavailabilityError('ServerRegistrationModule', 'getRegistrationInfoAsync')\n  );\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}