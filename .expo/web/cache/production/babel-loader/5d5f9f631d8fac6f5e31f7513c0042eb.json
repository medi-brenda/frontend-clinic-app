{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _regeneratorRuntime from\"@babel/runtime/regenerator\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;})),keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){_defineProperty(target,key,source[key]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}return target;}import*as Application from'expo-application';import Constants from'expo-constants';import{Platform,CodedError,UnavailabilityError}from'expo-modules-core';import{setAutoServerRegistrationEnabledAsync}from\"./DevicePushTokenAutoRegistration.fx\";import ServerRegistrationModule from\"./ServerRegistrationModule\";import getDevicePushTokenAsync from\"./getDevicePushTokenAsync\";var productionBaseUrl='https://exp.host/--/api/v2/';export default function getExpoPushTokenAsync(){var _Constants$manifest,_Constants$manifest2,_Constants$manifest2$,_Constants$manifest2$2,_Constants$manifest3,_Constants$manifest4,_Constants$manifest4$,_Constants$manifest4$2,_Constants$manifest5,_options$baseUrl,_options$url;var options,devicePushToken,deviceId,experienceId,projectId,applicationId,type,development,baseUrl,url,body,response,statusInfo,_body,expoPushToken,_args=arguments;return _regeneratorRuntime.async(function getExpoPushTokenAsync$(_context){while(1){switch(_context.prev=_context.next){case 0:options=_args.length>0&&_args[0]!==undefined?_args[0]:{};_context.t0=options.devicePushToken;if(_context.t0){_context.next=6;break;}_context.next=5;return _regeneratorRuntime.awrap(getDevicePushTokenAsync());case 5:_context.t0=_context.sent;case 6:devicePushToken=_context.t0;_context.t1=options.deviceId;if(_context.t1){_context.next=12;break;}_context.next=11;return _regeneratorRuntime.awrap(getDeviceIdAsync());case 11:_context.t1=_context.sent;case 12:deviceId=_context.t1;experienceId=options.experienceId||((_Constants$manifest=Constants.manifest)==null?void 0:_Constants$manifest.originalFullName)||((_Constants$manifest2=Constants.manifest2)==null?void 0:(_Constants$manifest2$=_Constants$manifest2.extra)==null?void 0:(_Constants$manifest2$2=_Constants$manifest2$.expoClient)==null?void 0:_Constants$manifest2$2.originalFullName)||((_Constants$manifest3=Constants.manifest)==null?void 0:_Constants$manifest3.id);projectId=options.projectId||((_Constants$manifest4=Constants.manifest2)==null?void 0:(_Constants$manifest4$=_Constants$manifest4.extra)==null?void 0:(_Constants$manifest4$2=_Constants$manifest4$.eas)==null?void 0:_Constants$manifest4$2.projectId)||((_Constants$manifest5=Constants.manifest)==null?void 0:_Constants$manifest5.projectId);if(!(!experienceId&&!projectId)){_context.next=17;break;}throw new CodedError('ERR_NOTIFICATIONS_NO_EXPERIENCE_ID',\"No experienceId or projectId found. If one or the other can't be inferred from the manifest (eg. in bare workflow), you have to pass one in yourself.\");case 17:applicationId=options.applicationId||Application.applicationId;if(applicationId){_context.next=20;break;}throw new CodedError('ERR_NOTIFICATIONS_NO_APPLICATION_ID',\"No applicationId found. If it can't be inferred from native configuration by expo-application, you have to pass it in yourself.\");case 20:type=options.type||getTypeOfToken(devicePushToken);_context.t2=options.development;if(_context.t2){_context.next=26;break;}_context.next=25;return _regeneratorRuntime.awrap(shouldUseDevelopmentNotificationService());case 25:_context.t2=_context.sent;case 26:development=_context.t2;baseUrl=(_options$baseUrl=options.baseUrl)!=null?_options$baseUrl:productionBaseUrl;url=(_options$url=options.url)!=null?_options$url:baseUrl+\"push/getExpoPushToken\";body=_objectSpread({type:type,deviceId:deviceId.toLowerCase(),development:development,appId:applicationId,deviceToken:getDeviceToken(devicePushToken)},projectId?{projectId:projectId}:{experienceId:experienceId});_context.next=32;return _regeneratorRuntime.awrap(fetch(url,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}).catch(function(error){throw new CodedError('ERR_NOTIFICATIONS_NETWORK_ERROR',\"Error encountered while fetching Expo token: \"+error+\".\");}));case 32:response=_context.sent;if(response.ok){_context.next=45;break;}statusInfo=response.statusText||response.status;_body=undefined;_context.prev=36;_context.next=39;return _regeneratorRuntime.awrap(response.text());case 39:_body=_context.sent;_context.next=44;break;case 42:_context.prev=42;_context.t3=_context[\"catch\"](36);case 44:throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR',\"Error encountered while fetching Expo token, expected an OK response, received: \"+statusInfo+\" (body: \\\"\"+_body+\"\\\").\");case 45:_context.t4=getExpoPushToken;_context.next=48;return _regeneratorRuntime.awrap(parseResponse(response));case 48:_context.t5=_context.sent;expoPushToken=(0,_context.t4)(_context.t5);_context.prev=50;if(!(options.url||options.baseUrl)){_context.next=55;break;}console.debug(\"[expo-notifications] Since the URL endpoint to register in has been customized in the options, expo-notifications won't try to auto-update the device push token on the server.\");_context.next=57;break;case 55:_context.next=57;return _regeneratorRuntime.awrap(setAutoServerRegistrationEnabledAsync(true));case 57:_context.next=62;break;case 59:_context.prev=59;_context.t6=_context[\"catch\"](50);console.warn('[expo-notifications] Could not enable automatically registering new device tokens with the Expo notification service',_context.t6);case 62:return _context.abrupt(\"return\",{type:'expo',data:expoPushToken});case 63:case\"end\":return _context.stop();}}},null,null,[[36,42],[50,59]],Promise);}function parseResponse(response){return _regeneratorRuntime.async(function parseResponse$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.prev=0;_context2.next=3;return _regeneratorRuntime.awrap(response.json());case 3:return _context2.abrupt(\"return\",_context2.sent);case 6:_context2.prev=6;_context2.t0=_context2[\"catch\"](0);_context2.prev=8;_context2.t1=CodedError;_context2.t2=JSON;_context2.next=13;return _regeneratorRuntime.awrap(response.text());case 13:_context2.t3=_context2.sent;_context2.t4=_context2.t2.stringify.call(_context2.t2,_context2.t3);_context2.t5=\"Expected a JSON response from server when fetching Expo token, received body: \"+_context2.t4;_context2.t6=_context2.t5+\".\";throw new _context2.t1('ERR_NOTIFICATIONS_SERVER_ERROR',_context2.t6);case 20:_context2.prev=20;_context2.t7=_context2[\"catch\"](8);throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR',\"Expected a JSON response from server when fetching Expo token, received response: \"+JSON.stringify(response)+\".\");case 23:case\"end\":return _context2.stop();}}},null,null,[[0,6],[8,20]],Promise);}function getExpoPushToken(data){if(!data||!(typeof data==='object')||!data.data||!(typeof data.data==='object')||!data.data.expoPushToken||!(typeof data.data.expoPushToken==='string')){throw new CodedError('ERR_NOTIFICATIONS_SERVER_ERROR',\"Malformed response from server, expected \\\"{ data: { expoPushToken: string } }\\\", received: \"+JSON.stringify(data,null,2)+\".\");}return data.data.expoPushToken;}function getDeviceIdAsync(){return _regeneratorRuntime.async(function getDeviceIdAsync$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:_context3.prev=0;if(ServerRegistrationModule.getInstallationIdAsync){_context3.next=3;break;}throw new UnavailabilityError('ExpoServerRegistrationModule','getInstallationIdAsync');case 3:_context3.next=5;return _regeneratorRuntime.awrap(ServerRegistrationModule.getInstallationIdAsync());case 5:return _context3.abrupt(\"return\",_context3.sent);case 8:_context3.prev=8;_context3.t0=_context3[\"catch\"](0);throw new CodedError('ERR_NOTIF_DEVICE_ID',\"Could not have fetched installation ID of the application: \"+_context3.t0+\".\");case 11:case\"end\":return _context3.stop();}}},null,null,[[0,8]],Promise);}function getDeviceToken(devicePushToken){if(typeof devicePushToken.data==='string'){return devicePushToken.data;}return JSON.stringify(devicePushToken.data);}function shouldUseDevelopmentNotificationService(){var notificationServiceEnvironment;return _regeneratorRuntime.async(function shouldUseDevelopmentNotificationService$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:if(!(Platform.OS==='ios')){_context4.next=11;break;}_context4.prev=1;_context4.next=4;return _regeneratorRuntime.awrap(Application.getIosPushNotificationServiceEnvironmentAsync());case 4:notificationServiceEnvironment=_context4.sent;if(!(notificationServiceEnvironment==='development')){_context4.next=7;break;}return _context4.abrupt(\"return\",true);case 7:_context4.next=11;break;case 9:_context4.prev=9;_context4.t0=_context4[\"catch\"](1);case 11:return _context4.abrupt(\"return\",false);case 12:case\"end\":return _context4.stop();}}},null,null,[[1,9]],Promise);}function getTypeOfToken(devicePushToken){switch(devicePushToken.type){case'ios':return'apns';case'android':return'fcm';default:return devicePushToken.type;}}","map":{"version":3,"sources":["../src/getExpoPushTokenAsync.ts"],"names":[],"mappings":"o4BAAA,MAAO,GAAK,CAAA,WAAZ,KAA6B,kBAA7B,CACA,MAAO,CAAA,SAAP,KAAsB,gBAAtB,CACA,OAAS,QAAT,CAAmB,UAAnB,CAA+B,mBAA/B,KAA0D,mBAA1D,CAEA,OAAS,qCAAT,4CACA,MAAO,CAAA,wBAAP,kCAEA,MAAO,CAAA,uBAAP,iCAEA,GAAM,CAAA,iBAAiB,CAAG,6BAA1B,CAmBA,cAAe,SAAe,CAAA,qBAAf,0gBAAqC,OAArC,+CAAwD,EAAxD,aACW,OAAO,CAAC,eADnB,yFAC6C,uBAAuB,EADpE,0CACP,eADO,yBAGI,OAAO,CAAC,QAHZ,2FAG+B,gBAAgB,EAH/C,4CAGP,QAHO,aAKP,YALO,CAMX,OAAO,CAAC,YAAR,wBACA,SAAS,CAAC,QADV,eACA,oBAAoB,gBADpB,0BAEA,SAAS,CAAC,SAFV,sCAEA,qBAAqB,KAFrB,uCAEA,sBAA4B,UAF5B,eAEA,uBAAwC,gBAFxC,0BAGA,SAAS,CAAC,QAHV,eAGA,qBAAoB,EAHpB,CANW,CAWP,SAXO,CAYX,OAAO,CAAC,SAAR,yBACA,SAAS,CAAC,SADV,sCACA,qBAAqB,KADrB,uCACA,sBAA4B,GAD5B,eACA,uBAAiC,SADjC,0BAEA,SAAS,CAAC,QAFV,eAEA,qBAAoB,SAFpB,CAZW,MAgBT,CAAC,YAAD,EAAiB,CAAC,SAhBT,gCAiBL,IAAI,CAAA,UAAJ,CACJ,oCADI,CAEJ,uJAFI,CAjBK,SAuBP,aAvBO,CAuBS,OAAO,CAAC,aAAR,EAAyB,WAAW,CAAC,aAvB9C,IAwBR,aAxBQ,+BAyBL,IAAI,CAAA,UAAJ,CACJ,qCADI,CAEJ,iIAFI,CAzBK,SA8BP,IA9BO,CA8BA,OAAO,CAAC,IAAR,EAAgB,cAAc,CAAC,eAAD,CA9B9B,aA+BO,OAAO,CAAC,WA/Bf,2FA+BqC,uCAAuC,EA/B5E,4CA+BP,WA/BO,aAiCP,OAjCO,mBAiCG,OAAO,CAAC,OAjCX,yBAiCsB,iBAjCtB,CAkCP,GAlCO,eAkCD,OAAO,CAAC,GAlCP,qBAkCiB,OAlCjB,yBAoCP,IApCO,gBAqCX,IAAI,CAAJ,IArCW,CAsCX,QAAQ,CAAE,QAAQ,CAAC,WAAT,EAtCC,CAuCX,WAAW,CAAX,WAvCW,CAwCX,KAAK,CAAE,aAxCI,CAyCX,WAAW,CAAE,cAAc,CAAC,eAAD,CAzChB,EA0CP,SAAS,CAAG,CAAE,SAAS,CAAT,SAAF,CAAH,CAAmB,CAAE,YAAY,CAAZ,YAAF,CA1CrB,oDA6CU,KAAK,CAAC,GAAD,CAAM,CAChC,MAAM,CAAE,MADwB,CAEhC,OAAO,CAAE,CACP,eAAgB,kBADT,CAFuB,CAKhC,IAAI,CAAE,IAAI,CAAC,SAAL,CAAe,IAAf,CAL0B,CAAN,CAAL,CAMpB,KANoB,CAMd,SAAC,KAAD,CAAU,CACjB,KAAM,IAAI,CAAA,UAAJ,CACJ,iCADI,iDAE4C,KAF5C,KAAN,CAID,CAXsB,CA7CV,UA6CP,QA7CO,kBA0DR,QAAQ,CAAC,EA1DD,0BA2DL,UA3DK,CA2DQ,QAAQ,CAAC,UAAT,EAAuB,QAAQ,CAAC,MA3DxC,CA4DP,KA5DO,CA4DoB,SA5DpB,oEA8DI,QAAQ,CAAC,IAAT,EA9DJ,UA8DT,KA9DS,8GAkEL,IAAI,CAAA,UAAJ,CACJ,gCADI,oFAE+E,UAF/E,cAEqG,KAFrG,QAlEK,qBAwES,gBAxET,mDAwEgC,aAAa,CAAC,QAAD,CAxE7C,oCAwEP,aAxEO,oDA2EP,OAAO,CAAC,GAAR,EAAe,OAAO,CAAC,OA3EhB,2BA4ET,OAAO,CAAC,KAAR,oLA5ES,iFAgFH,qCAAqC,CAAC,IAAD,CAhFlC,4FAmFX,OAAO,CAAC,IAAR,CACE,sHADF,cAnFW,wCAyFN,CACL,IAAI,CAAE,MADD,CAEL,IAAI,CAAE,aAFD,CAzFM,qFA+Ff,QAAe,CAAA,aAAf,CAA6B,QAA7B,+LAEiB,QAAQ,CAAC,IAAT,EAFjB,mJAKgB,UALhB,cAOyF,IAPzF,oDAQgB,QAAQ,CAAC,IAAT,EARhB,gEAO8F,SAP9F,iMAMQ,gCANR,iFAYY,IAAI,CAAA,UAAJ,CACJ,gCADI,sFAEiF,IAAI,CAAC,SAAL,CACnF,QADmF,CAFjF,KAZZ,kFAsBA,QAAS,CAAA,gBAAT,CAA0B,IAA1B,CAAmC,CACjC,GACE,CAAC,IAAD,EACA,EAAE,MAAO,CAAA,IAAP,GAAgB,QAAlB,CADA,EAEA,CAAC,IAAI,CAAC,IAFN,EAGA,EAAE,MAAO,CAAA,IAAI,CAAC,IAAZ,GAAqB,QAAvB,CAHA,EAIA,CAAC,IAAI,CAAC,IAAL,CAAU,aAJX,EAKA,EAAE,MAAO,CAAA,IAAI,CAAC,IAAL,CAAU,aAAjB,GAAmC,QAArC,CANF,CAOE,CACA,KAAM,IAAI,CAAA,UAAJ,CACJ,gCADI,gGAEyF,IAAI,CAAC,SAAL,CAC3F,IAD2F,CAE3F,IAF2F,CAG3F,CAH2F,CAFzF,KAAN,CAQD,CAED,MAAO,CAAA,IAAI,CAAC,IAAL,CAAU,aAAjB,CACD,CAGD,QAAe,CAAA,gBAAf,oJAES,wBAAwB,CAAC,sBAFlC,+BAGY,IAAI,CAAA,mBAAJ,CAAwB,8BAAxB,CAAwD,wBAAxD,CAHZ,0DAMiB,wBAAwB,CAAC,sBAAzB,EANjB,0HAQU,IAAI,CAAA,UAAJ,CACJ,qBADI,gFARV,2EAeA,QAAS,CAAA,cAAT,CAAwB,eAAxB,CAAwD,CACtD,GAAI,MAAO,CAAA,eAAe,CAAC,IAAvB,GAAgC,QAApC,CAA8C,CAC5C,MAAO,CAAA,eAAe,CAAC,IAAvB,CACD,CAED,MAAO,CAAA,IAAI,CAAC,SAAL,CAAe,eAAe,CAAC,IAA/B,CAAP,CACD,CAGD,QAAe,CAAA,uCAAf,+LACM,QAAQ,CAAC,EAAT,GAAgB,KADtB,+FAIc,WAAW,CAAC,6CAAZ,EAJd,SAGY,8BAHZ,qBAKU,8BAA8B,GAAK,aAL7C,4DAMe,IANf,qIAaS,KAbT,4EAiBA,QAAS,CAAA,cAAT,CAAwB,eAAxB,CAAwD,CACtD,OAAQ,eAAe,CAAC,IAAxB,EACE,IAAK,KAAL,CACE,MAAO,MAAP,CACF,IAAK,SAAL,CACE,MAAO,KAAP,CAEF,QACE,MAAO,CAAA,eAAe,CAAC,IAAvB,CAPJ,CASD","sourcesContent":["import * as Application from 'expo-application';\nimport Constants from 'expo-constants';\nimport { Platform, CodedError, UnavailabilityError } from 'expo-modules-core';\n\nimport { setAutoServerRegistrationEnabledAsync } from './DevicePushTokenAutoRegistration.fx';\nimport ServerRegistrationModule from './ServerRegistrationModule';\nimport { DevicePushToken, ExpoPushToken } from './Tokens.types';\nimport getDevicePushTokenAsync from './getDevicePushTokenAsync';\n\nconst productionBaseUrl = 'https://exp.host/--/api/v2/';\n\ninterface Options {\n  // Endpoint URL override\n  baseUrl?: string;\n\n  // Request URL override\n  url?: string;\n\n  // Request body overrides\n  type?: string;\n  deviceId?: string;\n  development?: boolean;\n  experienceId?: string;\n  projectId?: string;\n  applicationId?: string;\n  devicePushToken?: DevicePushToken;\n}\n\nexport default async function getExpoPushTokenAsync(options: Options = {}): Promise<ExpoPushToken> {\n  const devicePushToken = options.devicePushToken || (await getDevicePushTokenAsync());\n\n  const deviceId = options.deviceId || (await getDeviceIdAsync());\n\n  const experienceId =\n    options.experienceId ||\n    Constants.manifest?.originalFullName ||\n    Constants.manifest2?.extra?.expoClient?.originalFullName ||\n    Constants.manifest?.id;\n\n  const projectId =\n    options.projectId ||\n    Constants.manifest2?.extra?.eas?.projectId ||\n    Constants.manifest?.projectId;\n\n  if (!experienceId && !projectId) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NO_EXPERIENCE_ID',\n      \"No experienceId or projectId found. If one or the other can't be inferred from the manifest (eg. in bare workflow), you have to pass one in yourself.\"\n    );\n  }\n\n  const applicationId = options.applicationId || Application.applicationId;\n  if (!applicationId) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NO_APPLICATION_ID',\n      \"No applicationId found. If it can't be inferred from native configuration by expo-application, you have to pass it in yourself.\"\n    );\n  }\n  const type = options.type || getTypeOfToken(devicePushToken);\n  const development = options.development || (await shouldUseDevelopmentNotificationService());\n\n  const baseUrl = options.baseUrl ?? productionBaseUrl;\n  const url = options.url ?? `${baseUrl}push/getExpoPushToken`;\n\n  const body = {\n    type,\n    deviceId: deviceId.toLowerCase(),\n    development,\n    appId: applicationId,\n    deviceToken: getDeviceToken(devicePushToken),\n    ...(projectId ? { projectId } : { experienceId }),\n  };\n\n  const response = await fetch(url, {\n    method: 'POST',\n    headers: {\n      'content-type': 'application/json',\n    },\n    body: JSON.stringify(body),\n  }).catch((error) => {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_NETWORK_ERROR',\n      `Error encountered while fetching Expo token: ${error}.`\n    );\n  });\n\n  if (!response.ok) {\n    const statusInfo = response.statusText || response.status;\n    let body: string | undefined = undefined;\n    try {\n      body = await response.text();\n    } catch {\n      // do nothing\n    }\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_SERVER_ERROR',\n      `Error encountered while fetching Expo token, expected an OK response, received: ${statusInfo} (body: \"${body}\").`\n    );\n  }\n\n  const expoPushToken = getExpoPushToken(await parseResponse(response));\n\n  try {\n    if (options.url || options.baseUrl) {\n      console.debug(\n        `[expo-notifications] Since the URL endpoint to register in has been customized in the options, expo-notifications won't try to auto-update the device push token on the server.`\n      );\n    } else {\n      await setAutoServerRegistrationEnabledAsync(true);\n    }\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Could not enable automatically registering new device tokens with the Expo notification service',\n      e\n    );\n  }\n\n  return {\n    type: 'expo',\n    data: expoPushToken,\n  };\n}\n\nasync function parseResponse(response: Response) {\n  try {\n    return await response.json();\n  } catch {\n    try {\n      throw new CodedError(\n        'ERR_NOTIFICATIONS_SERVER_ERROR',\n        `Expected a JSON response from server when fetching Expo token, received body: ${JSON.stringify(\n          await response.text()\n        )}.`\n      );\n    } catch {\n      throw new CodedError(\n        'ERR_NOTIFICATIONS_SERVER_ERROR',\n        `Expected a JSON response from server when fetching Expo token, received response: ${JSON.stringify(\n          response\n        )}.`\n      );\n    }\n  }\n}\n\nfunction getExpoPushToken(data: any) {\n  if (\n    !data ||\n    !(typeof data === 'object') ||\n    !data.data ||\n    !(typeof data.data === 'object') ||\n    !data.data.expoPushToken ||\n    !(typeof data.data.expoPushToken === 'string')\n  ) {\n    throw new CodedError(\n      'ERR_NOTIFICATIONS_SERVER_ERROR',\n      `Malformed response from server, expected \"{ data: { expoPushToken: string } }\", received: ${JSON.stringify(\n        data,\n        null,\n        2\n      )}.`\n    );\n  }\n\n  return data.data.expoPushToken as string;\n}\n\n// Same as in DevicePushTokenAutoRegistration\nasync function getDeviceIdAsync() {\n  try {\n    if (!ServerRegistrationModule.getInstallationIdAsync) {\n      throw new UnavailabilityError('ExpoServerRegistrationModule', 'getInstallationIdAsync');\n    }\n\n    return await ServerRegistrationModule.getInstallationIdAsync();\n  } catch (e) {\n    throw new CodedError(\n      'ERR_NOTIF_DEVICE_ID',\n      `Could not have fetched installation ID of the application: ${e}.`\n    );\n  }\n}\n\nfunction getDeviceToken(devicePushToken: DevicePushToken) {\n  if (typeof devicePushToken.data === 'string') {\n    return devicePushToken.data;\n  }\n\n  return JSON.stringify(devicePushToken.data);\n}\n\n// Same as in DevicePushTokenAutoRegistration\nasync function shouldUseDevelopmentNotificationService() {\n  if (Platform.OS === 'ios') {\n    try {\n      const notificationServiceEnvironment =\n        await Application.getIosPushNotificationServiceEnvironmentAsync();\n      if (notificationServiceEnvironment === 'development') {\n        return true;\n      }\n    } catch {\n      // We can't do anything here, we'll fallback to false then.\n    }\n  }\n\n  return false;\n}\n\n// Same as in DevicePushTokenAutoRegistration\nfunction getTypeOfToken(devicePushToken: DevicePushToken) {\n  switch (devicePushToken.type) {\n    case 'ios':\n      return 'apns';\n    case 'android':\n      return 'fcm';\n    // This probably will error on server, but let's make this function future-safe.\n    default:\n      return devicePushToken.type;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}